
//
//          Copyright Richard Allen Hogaboom 1997 - 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

/*
 * NAME
 *
 *     MKRdxPat_perf_bgp
 *
 * USAGE
 *
 *     ./MKRdxPat_perf_bgp [-c{1-2}] [-r{1-3}] [-s{1-86400}] [-b{1-100000}]
 *
 * ARGUMENTS
 *
 *     None
 *
 * OPTIONS
 *
 *     -c{1-2}      - option 1: repeatedly insert()(fill - monatonic keys)/remove()(empty)
 *                              trie(1 default)
 *                    option 2: fill trie(monatonic keys) then do max_rdx_nodes search()'s
 *                              with random keys
 *
 *     -r{1-3}      - option to set key encoding scheme
 *                    store keys in trie as:
 *                        1 - d(3).d(3).d(3).d(3)/n(2) ascii(up to 18 bytes)
 *                        2 - d(3)d(3)d(3)d(3)n(2) ascii(up to 14 bytes)
 *                        3 - (32 bit uint)(4)n(1) binary(5 bytes)
 *
 *     -s{1-86400}  - minimum run time(secs)(30 default)
 *
 *     -b{1-100000} - c option 1: trie will be filled/emptied this many times
 *                    c option 2: the random key set generated on filling the trie will be
 *                                searched for this many times
 *                    (100 default)
 *
 * DESCRIPTION
 *
 *     MKRdxPat_perf_bgp is used to evaluate the performance of the MKRdxPat class
 *     (Multi-Key Radix Fast Search) algorithm implementation.  this test uses a file of
 *     BGP routing information with the first field IPv4 prefixes as keys.  the trie has
 *     fixed values for max_rdx_nodes(582378), num_keys(1) and max_key_bytes(18).  there
 *     are three ways to encode the keys from the prefixes which are in dotted decimal
 *     form plus the network mask.  these are(from the -r option):
 *         1 - d(3).d(3).d(3).d(3)/n(2) ascii(up to 18 bytes)
 *         2 - d(3)d(3)d(3)d(3)n(2) ascii(up to 14 bytes)
 *         3 - (32 bit uint)(4)n(1) binary(5 bytes)
 *     insert in 'struct app_data{}' your application data node.  Re-compile.  run
 *     ./MKRdxPat_perf_bgp [options].  examine the MKRdxPat_perf_bgp.results file.
 *     see EXAMPLE OUTPUT below.  the file output includes:
 *         1. the data/time
 *         2. the full cmd line
 *         3. the -c option description
 *         4. the lscpu cmd output - provides some context on the hardware that was
 *                                   used to run the performance test
 *         5. the constructor arguments
 *         6. the trie size
 *         7. the option parameters
 *         8. the incremental number of operations(insert(), remove(), search())
 *            for whatever the -b option is set to
 *         9. the time(secs) the run took and the number of operations performed
 *            in that time
 *         10. the operations per second
 *     subsequent runs will append new data.
 *
 * NOTES
 *
 *     1. a more realistic performance evaluation my be had by modifying the code here to
 *        add additional steps always or typically used in your application.  for example,
 *        a call to memset() might be made before an insert()/remove()/search() since in
 *        many cases key arrays are zero filled starting with this.  also, some processing
 *        of node data might be done that is commonly application specific.
 *
 * DEPENDENCIES
 *
 *     MKRdxPat.hpp class
 *
 * BUGS AND LIMITATIONS
 *
 *     No bugs known
 *
 * EXAMPLE OUTPUT
 *
 *     ####################################################################################################
 *     Sat Apr 23 12:18:53 2016
 *
 *     ./MKRdxPat_perf_bgp 
 *
 *     PERFORMANCE TEST: Do repeated rdx->insert()(fill trie) / rdx->remove()(empty trie)
 *                       using bgp routing table prefix keys
 *
 *     lscpu:
 *
 *     Architecture:          x86_64
 *     CPU op-mode(s):        32-bit, 64-bit
 *     Byte Order:            Little Endian
 *     CPU(s):                2
 *     On-line CPU(s) list:   0,1
 *     Thread(s) per core:    1
 *     Core(s) per socket:    2
 *     Socket(s):             1
 *     NUMA node(s):          1
 *     Vendor ID:             AuthenticAMD
 *     CPU family:            15
 *     Model:                 107
 *     Model name:            AMD Athlon(tm) 64 X2 Dual Core Processor 4000+
 *     Stepping:              1
 *     CPU MHz:               2109.701
 *     BogoMIPS:              4219.40
 *     Virtualization:        AMD-V
 *     L1d cache:             64K
 *     L1i cache:             64K
 *     L2 cache:              512K
 *     NUMA node0 CPU(s):     0,1
 *     Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat
 *                            pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt
 *                            rdtscp lm 3dnowext 3dnow rep_good nopl pni cx16 lahf_lm cmp_legacy
 *                            svm extapic cr8_legacy 3dnowprefetch lbrv vmmcall
 *
 *     max_rdx_nodes = 582,378
 *     num_keys = 1
 *     max_key_bytes = 18
 *         (Modify MKRdxPat_perf.cpp with new parameters and re-compile.)
 *
 *     trie size = 121,717,351b
 *
 *     -c 1 - insert()/remove()(1 default) or search()(2)
 *     -r 1 - key encoding(1-3, 1 default)
 *     -s 30.000000 - minimum run time(sec, 30 default)
 *     -b 100 - block multiplier(100 default)
 *
 *     insert()/remove() increments: 116,475,600(100*2*max_rdx_nodes)
 *
 *     seconds = 110.515489  total inserts/removes = 116,475,600
 *
 *     operations per second = 1,053,930
 *
 * SEE ALSO
 *
 *     MKRdxPat_test - the MKRdxPat.hpp class test suite
 *     MKRdxPat_perf - performance testing with user adjustable contstructor arguments
 *
 * ACKNOWLEDGMENTS
 *     Pavel Odintsov(pavel.odintsov@gmail.com)
 *
 *     Pavel provided the file of BGP routing prefixes from one of his BGP speakers
 *
 * AUTHOR
 *
 *     Richard A Hogaboom
 *     richard.hogaboom@gmail.com
 *
 */


//using std::ofstream;

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cstring>
#include <ctime>
#include <stdio.h>

#include <unistd.h>

#include "MKRdxPat.hpp"

using namespace MultiKeyRdxPat;

using std::cerr;


// take the difference of two timespec structs and return this in a timespec struct
    struct timespec
timespec_diff
    (
        struct timespec start,
        struct timespec end
    )
{
    struct timespec temp;

    if ((end.tv_nsec - start.tv_nsec) < 0) 
    {
        temp.tv_sec = end.tv_sec - start.tv_sec - 1;
        temp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
    } 
    else 
    {
        temp.tv_sec = end.tv_sec - start.tv_sec;
        temp.tv_nsec = end.tv_nsec - start.tv_nsec;
    }

    return temp;
}

    int
main
    (
        int argc,
        char **argv
    )
{
    const int TMPSTR_SIZE = 256;
    char tmpstr[TMPSTR_SIZE];

    extern int optind;

    const int BGP_SIZE = 582378;
    const int MAX_LINE_SIZE = 256;
    const int MAX_PREFIX_SIZE = 18;

    string usage =
        "usage: ./MKRdxPat_perf [-c{1-2}] [-s{1-86400}] [-b{1-100000}]\n"
        "\n"
        "    -c{1-2}      - option 1: repeatedly insert()(fill)/remove()(empty) trie(1 default) using bgp routing table keys.\n"
        "                   option 2: fill trie then do max_rdx_nodes random search()'s with bgp routing table keys.\n"
        "\n"
        "    -r{1-3}      - option to set key encoding scheme\n"
        "                   store keys in trie as:\n"
        "                       1 - d(3).d(3).d(3).d(3)/n(2) ascii(up to 18 bytes)\n"
        "                       2 - d(3)d(3)d(3)d(3)n(2) ascii(up to 14 bytes)\n"
        "                       3 - (32 bit uint)(4)n(1) binary(5 bytes)\n"
        "\n"
        "    -s{1-86400}  - minimum run time(secs)(30 default)\n"
        "\n"
        "    -b{1-100000} - c option 1: trie will be filled/emptied this many times\n"
        "                   c option 2: the random key set generated on filling the trie will be\n"
        "                               searched for this many times\n"
        "                   (100 default)\n";

    // enable printf("%'d", n); for commas in large numbers
    setlocale(LC_NUMERIC, "");

    ofstream os;
    os.open("MKRdxPat_perf_bgp.results", ofstream::app|ofstream::out);

    // cmd line option defaults
    int pmode_opt = 1;  // performance test case option
    double rtime_opt = 30.;  // run time option
    int block_multiply_opt = 100;  // block multiply option
    int router_key_opt = 1;  // router key encoding default

    opterr = 0;
    int opt;
    while ( (opt = getopt(argc, argv, "c:r:s:b:")) != -1 )
    {
        switch (opt)
        {
            case 'c':
                pmode_opt = atoi(optarg);
                if ( pmode_opt < 1 || pmode_opt > 2 )
                {
                    cerr << usage << "-c option out of range(1-2): " << pmode_opt << "\n";
                    exit(1);
                }
                break;

            case 'r':
                router_key_opt = atof(optarg);
                if ( router_key_opt < 1 || router_key_opt > 3 )
                {
                    cerr << usage << "-r option out of range(1 to 3): " << router_key_opt << "\n";
                    exit(1);
                }
                break;

            case 's':
                rtime_opt = atof(optarg);
                if ( rtime_opt < 1 || rtime_opt > 86400 )
                {
                    cerr << usage << "-s option out of range(1 to 86400): " << rtime_opt << "\n";
                    exit(1);
                }
                break;

            case 'b':
                block_multiply_opt = atoi(optarg);
                if ( block_multiply_opt < 1 || block_multiply_opt > 100000 )
                {
                    cerr << usage << "-b option out of range(1 to 100000): " << block_multiply_opt << "\n";
                    exit(1);
                }
                break;

            case '?':
                cerr << usage << "\n";
                return 1;

            default:
                cerr << "abort(): " << opt << " = getopt(argc, argv, \"c:s:b:\")" << "\n";
                abort();
        }
    }

    if ( optind < argc )
    {
        cerr << usage << "No arguments allowed\n";
        exit(0);
    }

    //
    // change only struct app_data {}; if desired and nothing else
    //
    // ================================================

    // MKRdxPat.hpp class constructor arguments
    const int max_rdx_nodes = BGP_SIZE;  // fixed - routing table entries
    const int num_keys      = 1;  // fixed - one key(prefix) in routing table

    // store keys in trie as:\n"
    //     1 - d(3).d(3).d(3).d(3)/n(2) ascii(up to 18 bytes)
    //     2 - d(3)d(3)d(3)d(3)n(2) ascii(up to 14 bytes)
    //     3 - (32 bit uint)(4)n(1) binary(5 bytes)
    const int max_key_bytes = MAX_PREFIX_SIZE;

    // application data of type app_data defined here
    struct app_data
    {
        int i;
    };

    // ================================================


    // holds sets of keys for max_rdx_nodes sets with num_keys keys of
    // max_key_bytes length with all key booleans set to 1
    // NOTE: the static keyword is needed to ensure that large rdx_key[][][]
    //       arrays do no blow the stack
    static unsigned char rdx_key[max_rdx_nodes][num_keys][1+max_key_bytes];

    app_data *app_datap;

    // set gm time string
    time_t rawtime;
    struct tm * timeinfo;

    time(&rawtime);
    timeinfo = gmtime(&rawtime);
    strftime(tmpstr, TMPSTR_SIZE, "%c", timeinfo);

    os << "####################################################################################################\n"
       << tmpstr << "\n\n";

    for ( int i = 0 ; i < argc ; i++ )
    {
        os << argv[i] << " ";
    }
    os << "\n\n";

    if ( pmode_opt == 1 )
    {
        os << "PERFORMANCE TEST: Do repeated rdx->insert()(fill trie) / rdx->remove()(empty trie)\n"
              "                  using bgp routing table prefix keys\n\nlscpu:\n\n";
    }
    if ( pmode_opt == 2 )
    {
        os << "PERFORMANCE TEST: Do repeated rdx->search()\n"
              "                  using bgp routing table prefix keys/random search\n\nlscpu:\n";
    }

    os.close();

    system("lscpu >> MKRdxPat_perf_bgp.results");

    os.open("MKRdxPat_perf_bgp.results", ofstream::app|ofstream::out);

    FILE *bgpfp = fopen("BGP_routing_table_3peersnap_04102016_as198068", "r");

    static char key[BGP_SIZE][MAX_PREFIX_SIZE+1];
    memset(key, 0, sizeof(key));

    int n = 0;
    char line[MAX_LINE_SIZE];
    char prefix[MAX_PREFIX_SIZE+1];
    while ( fscanf(bgpfp, "%[^\n]\n", line) != EOF )  // read lines
    {
        unsigned int octet1, octet2, octet3, octet4, mask;

        memset(prefix, 0, sizeof(prefix));
        sscanf(line, "%s", prefix);  // get first field prefix
        switch ( router_key_opt )
        {
            case 1:  // 1 - d(3).d(3).d(3).d(3)/n(2) ascii(up to 18 bytes)
                strcpy(&key[n++][0], prefix);
                break;

            case 2:  // 2 - d(3)d(3)d(3)d(3)n(2) ascii(up to 14 bytes)
                sscanf(prefix, "%d.%d.%d.%d/%d", &octet1, &octet2, &octet3, &octet4, &mask);
                sprintf(&key[n][0], "%03d%03d%03d%03d%02d", octet1, octet2, octet3, octet4, mask);
                n++;
                break;

            case 3:  // 3 - (32 bit uint)(4)n(1) binary(5 bytes)
                unsigned int ip32;
                unsigned char umask;

                sscanf(prefix, "%d.%d.%d.%d/%d", &octet1, &octet2, &octet3, &octet4, &mask);
                ip32 = (octet1 * pow(2, 24)) + (octet2 * pow(2, 16)) + (octet3 * pow(2, 8)) + (octet4);
                umask = mask;
                memmove(&key[n][0], &ip32, 4);
                memmove(&key[n][4], &umask, 1);
                n++;
                break;
        }
    }

    // rdx_key[][][] - generate max_rdx_nodes nodes of num_keys keys of
    // max_key_bytes bytes and set all key booleans to 1
    for ( int n = 0 ; n < max_rdx_nodes ; n++ )
    {
        for ( int k = 0 ; k < num_keys ; k++ )
        {
            rdx_key[n][k][0] = 1;  // set key boolean to 1
            memmove(&rdx_key[n][k][1], &key[n][0], max_key_bytes);  // put key immediately after key boolean
        }
    }

    // MKRdxPat class trie constructor
    MKRdxPat<app_data> *rdx = new MKRdxPat<app_data>(max_rdx_nodes, num_keys, max_key_bytes);

    os << "\n";
    snprintf(tmpstr, sizeof(tmpstr), "\nmax_rdx_nodes = %'d\nnum_keys = %d\nmax_key_bytes = %d\n",
        max_rdx_nodes, num_keys, max_key_bytes);
    os << tmpstr;
    snprintf(tmpstr, sizeof(tmpstr), "    (Modify MKRdxPat_perf.cpp with new parameters and re-compile.)\n\n");
    os << tmpstr;

    snprintf(tmpstr, sizeof(tmpstr), "trie size = %'db\n\n", rdx->bsize());
    os << tmpstr;

    snprintf(tmpstr, sizeof(tmpstr), "-c %d - insert()/remove()(1 default) or search()(2)\n", pmode_opt);
    os << tmpstr;
    snprintf(tmpstr, sizeof(tmpstr), "-r %d - key encoding(1-3, 1 default)\n", router_key_opt);
    os << tmpstr;
    snprintf(tmpstr, sizeof(tmpstr), "-s %f - minimum run time(sec, 30 default)\n", rtime_opt);
    os << tmpstr;
    snprintf(tmpstr, sizeof(tmpstr), "-b %d - block multiplier(100 default)\n\n", block_multiply_opt);
    os << tmpstr;

    switch ( pmode_opt )
    {
        case 1:
            {
                long total_inserts_removes = 0;
                struct timespec tstart={0,0}, tend={0,0}, tdiff={0,0};
                double sec;
                int return_code;

                snprintf(tmpstr, sizeof(tmpstr), "insert()/remove() increments: %'d(%d*2*max_rdx_nodes)\n\n",
                    block_multiply_opt*2*max_rdx_nodes, block_multiply_opt);
                os << tmpstr;

                clock_gettime(CLOCK_MONOTONIC, &tstart);

                for (;;)
                {
                    for ( int i = 0 ; i < block_multiply_opt ; i++ )
                    {
                        for ( int n = 0 ; n < max_rdx_nodes ; n++ )
                        {
                            return_code = rdx->insert((unsigned char *)rdx_key[n], &app_datap);

                            if ( return_code != 0 )
                            {
                                os << "insert(): data node = " << n << " return_code = " << return_code << "\n";
                            }
                        }

                        for ( int n = 0 ; n < max_rdx_nodes ; n++ )
                        {
                            app_datap = rdx->remove((unsigned char *)rdx_key[n]);

                            if ( app_datap == NULL )
                            {
                                os << "remove(): data node = " << n << " return = NULL" << "\n";
                            }
                        }
                    }

                    total_inserts_removes += max_rdx_nodes*2*block_multiply_opt;

                    clock_gettime(CLOCK_MONOTONIC, &tend);

                    tdiff = timespec_diff(tstart, tend);
                    sec = tdiff.tv_sec + tdiff.tv_nsec/1E9;

                    if ( sec > rtime_opt )
                    {
                        break;
                    }
                }

                snprintf(tmpstr, sizeof(tmpstr), "seconds = %f  total inserts/removes = %'ld\n\n", sec, total_inserts_removes);
                os << tmpstr;

                long ops_per_sec;
                ops_per_sec = total_inserts_removes/sec;
                snprintf(tmpstr, sizeof(tmpstr), "operations per second = %'ld\n\n", ops_per_sec);
                os << tmpstr;
            }
            break;

        case 2:
            {
                long total_searches = 0;
                int random[max_rdx_nodes];  // for random key search()
                struct timespec tstart={0,0}, tend={0,0}, tdiff={0,0};
                double sec;

                snprintf(tmpstr, sizeof(tmpstr), "search() increments: %'d(%d*max_rdx_nodes)\n\n",
                    block_multiply_opt*max_rdx_nodes, block_multiply_opt);
                os << tmpstr;

                srand(time(NULL));
                for ( int n = 0 ; n < max_rdx_nodes ; n++ )
                {
                    rdx->insert((unsigned char *)rdx_key[n], &app_datap);
                    random[n] = rand() % max_rdx_nodes;  // not crypto random - will produce some duplicates - ok
                }

                clock_gettime(CLOCK_MONOTONIC, &tstart);

                for (;;)
                {
                    for ( int i = 0 ; i < block_multiply_opt ; i++ )
                    {
                        for ( int n = 0 ; n < max_rdx_nodes ; n++ )
                        {
                            app_datap = rdx->search((unsigned char *)rdx_key[random[n]]);

                            if ( app_datap == NULL )
                            {
                                os << "search(): data node = " << n << " return = NULL" << "\n";
                            }

                            total_searches++;
                        }
                    }

                    clock_gettime(CLOCK_MONOTONIC, &tend);

                    tdiff = timespec_diff(tstart, tend);
                    sec = tdiff.tv_sec + tdiff.tv_nsec/1E9;

                    if ( sec > rtime_opt )
                    {
                        break;
                    }
                }

                snprintf(tmpstr, sizeof(tmpstr), "seconds = %f  total searches = %'ld\n\n", sec, total_searches);
                os << tmpstr;

                long ops_per_sec;
                ops_per_sec = total_searches/sec;
                snprintf(tmpstr, sizeof(tmpstr), "operations per second = %'ld\n\n", ops_per_sec);
                os << tmpstr;
            }
            break;

        default:
            {
                os << "Bad -c option.\n";
            }
            break;
    }
}

