#ifndef RDX_CPP_MKRDXPAT_H_
#define RDX_CPP_MKRDXPAT_H_

//
//          Copyright Richard Allen Hogaboom 1997 - 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

/*
 *======================================================================================================================
 *
 * File Names:
 *     MKRdxPat.hpp
 *
 *======================================================================================================================
 *
 * Member Functions:
 *
 *     struct app_data
 *     {
 *         int data;  // user specified application data structure
 *     };
 *
 *     MKRdxPat<app_data>
 *         (
 *             int MAX_RDX_NODES,
 *             int NUM_KEYS,
 *             int MAX_KEY_BYTES
 *         );
 *         e.g. MKRdxPat<app_data> *rdx = new MKRdxPat<app_data>(512, 3, 4);
 *
 *
 *     ~MKRdxPat()
 *         e.g. delete rdx;
 *
 *
 *     struct app_data
 *     {
 *         int data;  // user specified application data structure
 *     };
 *
 *         int
 *     insert
 *         (
 *             unsigned char *key,  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
 *             app_data **app_datapp
 *         );
 *         e.g. int return_code = rdx->insert((unsigned char *)key, &app_datap);
 *
 *
 *     struct app_data
 *     {
 *         int data;  // user specified application data structure
 *     };
 *
 *         app_data *
 *     search
 *         (
 *             unsigned char *key  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
 *         );
 *         e.g. app_data *app_datap = rdx->search((unsigned char *)key);
 *
 *
 *     struct app_data
 *     {
 *         int data;  // user specified application data structure
 *     }
 *
 *         app_data *
 *     remove
 *         (
 *             unsigned char *key  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
 *         );
 *         e.g. app_data *app_datap = rdx->remove((unsigned char *)key);
 *
 *
 *         int
 *     sort
 *         (
 *             app_data ***app_datappp,
 *             int k
 *         );
 *         e.g. int return_code = rdx->sort(&app_datapp, k);
 *
 *
 *         int
 *     alloc_nodes
 *         (
 *         );
 *         e.g. int alloc_nodes = rdx->alloc_nodes();
 *
 *
 *         int
 *     bsize
 *         (
 *         );
 *         e.g. int bsize = rdx->bsize();
 *
 *
 *         int
 *     max_rdx_nodes
 *         (
 *         );
 *         e.g. int max_rdx_nodes = rdx->max_rdx_nodes();
 *
 *
 *         int
 *     num_keys
 *         (
 *         );
 *         e.g. int num_keys = rdx->num_keys();
 *
 *
 *         int
 *     max_key_bytes 
 *         (
 *         );
 *         e.g. int max_key_bytes = rdx->max_key_bytes();
 *
 *
 *         MKRdxPat<app_data> *
 *     chg_max_rdx_nodes 
 *         (
 *             int new_max_rdx_nodes
 *         );
 *         e.g. MKRdxPat<app_data> *rdx_new = rdx_old->chg_max_rdx_nodes(new_max_rdx_nodes);
 *
 *
 *         int
 *     print
 *         (
 *             unsigned char *key,  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
 *             ofstream& os
 *         );
 *         e.g. int return_code = rdx->print(NULL, os);
 *         e.g. int return_code = rdx->print((unsigned char *)key, os);
 *
 *
 *         int
 *     verify
 *         (
 *             VERIFY_MODE vm,
 *             ofstream& os
 *         );
 *         e.g. int return_code = rdx->verify(ERR_CODE, os);
 *         e.g. int return_code = rdx->verify(ERR_CODE_PRINT, os);
 *
 *======================================================================================================================
 *
 * Description:
 *     The MKRdxPat class allows the allocation of a fixed sized contiguous data store that holds data nodes
 *     of an arbitrary structure that may be accessed with any number of keys of any size with the PATRICIA
 *     (Practical Algorithm To Retrieve Information Coded In Alphanumeric)(1,2,3) fast search algorithm.
 *     MKRdxPat is particularly suited to applications the require complex data structures be contiguously
 *     stored and accessed with an algorithm of known fast character with any of several possible keys,
 *     either singly of several simultaneously.
 *
 *     For example, a data structure that required either of an IPv4, IPv6 or MAC address key(s) to access
 *     data nodes.  In this case NUM_KEYS would be 3 and MAX_KEY_BYTES would be 16(the longest - see below).
 *
 *     The MKRdxPat class supports a data structure of MAX_RDX_NODES data nodes and NUM_KEYS keys per
 *     data node with keys of MAX_KEY_BYTES bytes or less.  The class constructor:
 *
 *         MKRdxPat<app_data> *rdx = new MKRdxPat<app_data>(MAX_RDX_NODES, NUM_KEYS, MAX_KEY_BYTES);
 *
 *     along with a:
 *
 *         struct app_data
 *         {
 *             // user data
 *         };
 *
 *     class constructor typename specifies the data structure.  A data node may be accessed with a single
 *     key or any number of keys simultaneously.  Keys must be unique within their key index(0 - NUM_KEYS-1),
 *     but not over different key indexes.  Member functions that require keys are passed the array:
 *
 *         unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
 *
 *     One extra prefix byte, a key boolean - required to be 0(ignore) or 1(search), is set with each key to
 *     specify if the key is to be used in the data node search.  It is suggested that the array be first
 *     memset() to 0:
 *
 *         memset(key, 0, NUM_KEYS * (1+MAX_KEY_BYTES));
 *
 *     and then only keys to be used copied in with the key boolean(set to 1) prepended.
 *
 *     In most cases the necessary keys will be of different lengths.  The MAX_KEY_BYTES constructor argument
 *     would be set to the longest of these.  All other shorter keys would be left justified in the key[][]
 *     array, that is, start just after the key boolean.  Thus, for the example above, the IPv6 key would use
 *     the full 16 bytes, the IPv4 key would use the first four bytes after the key boolean(with the rest(12)
 *     set to 0) and the MAC key would use the first 6 bytes after the key boolean(with the rest(10) set to
 *     0).  This was done to make the specification of the key[][] array and the code associated with
 *     processing it simpler.  Actually, the IPv4 and MAC addresses could be right justified, just so long as
 *     all the keys are always right justified and the other bytes are 0; you just have to be consistent
 *     within any given key index.  From the way that PATRICIA works the keys are examined from left to
 *     right.  Thus, it makes sense to left justify.  Then, the actual key bits are examined instead of
 *     examining irrelevent 0 bits first.  The suffixed 0 bits are not a factor in the data node search since
 *     the key bits on the left will find a data node if all inserts were made with the same number of key
 *     bits on the left e.g. 32 for an IPv4 address.  Example:
 *
 *                 kb key bytes
 *         IPv4 :  01 c0 a8 00 01 00 00 00 00 00 00 00 00 00 00 00 00 - 192.168.0.1
 *         IPv6 :  01 fe 80 00 00 00 00 00 00 02 21 2f ff fe b5 6e 10 - fe80::221:2fff:feb5:6e10
 *         MAC  :  01 00 21 2f b5 6e 10 00 00 00 00 00 00 00 00 00 00 - 00:21:2f:b5:6e:10
 *
 *     Let's suppose that we wanted to find a data node with just the IPv6 address.  We first memset()
 *     key[][] to 0.  We then add the IPv6 address with it's key boolean set to 1 and pass the key[][] array
 *     to the member functions.  Thus:
 *
 *                 kb key bytes
 *         IPv4 :  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 - 0
 *         IPv6 :  01 fe 80 00 00 00 00 00 00 02 21 2f ff fe b5 6e 10 - fe80::221:2fff:feb5:6e10
 *         MAC  :  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 - 0
 *
 *     See the member function summary above or a detailed member function usage comment before each
 *     function's code.  A verify() member function is provided that does extensive data structure memory
 *     analysis and a print() member function is provided that prints the structural details of all the
 *     branch and data nodes.
 *
 *     For a trie of NUM_KEYS keys, each data node will have NUM_KEYS branch nodes associated with it.  The
 *     number of actual data nodes in the data structure is MAX_RDX_NODES+1.  This extra node is for the
 *     initial branch nodes and initial data node with the impossible key of all 0xff's(1,2,3).  The number
 *     of user storable nodes is MAX_RDX_NODES.   The user, through the constructor, declares PNODEs,
 *     each of which contains a radix PATRICIA trie of MAX_RDX_NODES nodes with NUM_KEYS keys of
 *     at most MAX_KEY_BYTES bytes length.
 *
 *     These routines are a modification of the algorithm cited.  Specifically, the upward pointers used to
 *     terminate search are not used, and are instead used to point to data nodes as trie leaves.  In
 *     multi-key search with PATRICIA the upward pointer scheme will not work since each key would have
 *     pointed to a different branch node with it's associated data structure.  In multi-key PATRICIA search
 *     all keys must lead to the same data node.  The viability of multi-key radix PATRICIA search depends
 *     on the fact that each data node insertion requires only one new branch node for each key, thus the
 *     initial allocation of NUM_KEYS branch nodes with each data node.  This implementation has several
 *     additional branch and data node members not used in the original PATRICIA search algorithm.  These
 *     are for various purposes; related to changes in the original algorithm for multi-key search, related
 *     to changes in the original algorithm for leaf data nodes instead of upward pointers to data structures
 *     stored in branch nodes, related to printing, related to sorting and debugging.
 *
 *======================================================================================================================
 *
 * Operational Notes:
 *
 *     1. the first member of BNODE and DNODE typedefs, id, should not be moved.  when doing operations on the
 *        trie, a search will reference the id from a BNODE type initially and then terminate at a DNODE type.
 *
 *     2. the maximum number of key bits is MAX_KEY_BITS.  the impossible key in the initially allocated data
 *        node must be at least one bit longer.  this requires the data node storage for the keys to have one
 *        extra byte.
 *
 *     3. all keys are the same length - MAX_KEY_BYTES bytes.  the performance hit, the small memory savings
 *        and the added code complexity of having individually sized keys did not seem worth it.  thus, the
 *        longest required key will determine MAX_KEY_BYTES.  shorter keys may be left justified in the
 *        MAX_KEY_BYTES bytes.
 *
 *     4. it is suggested that the 'unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]' array be first memset() to
 *        0 and then all the keys to be used with key boolean 1 added in one operation(keys with key boolean
 *        0 are never needed) e.g. memset(key, 0, NUM_KEYS * (1+MAX_KEY_BYTES));.
 *
 *     5. multidemensional arrays in C++ are implemented by subscripting calloc()'ed memory with parameterized
 *        values calculated from the C array versions.  One, two and three dimensional arrays are illustrated
 *        as follows(see verify() for actual usage):
 *
 *        n -> subscripts max_rdx_nodes_
 *        k -> subscripts num_keys_
 *        b -> subscripts max_key_bytes_:
 *
 *        a. one dimensional:
 *           unsigned long verify_dnode_addrs_[max_rdx_nodes_+1];
 *               -> verify_dnode_addrs_[n]
 *
 *        b. two dimensional:
 *           unsigned long verify_bnode_addrs_[num_keys_][max_rdx_nodes_+1];
 *               -> verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n]
 *
 *        c. three dimensional:
 *           unsigned char verify_dnode_keys_[num_keys_][max_rdx_nodes_+1][max_key_bytes_];
 *               -> verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]
 *
 *======================================================================================================================
 *
 * Theoretic Notes:
 *
 *     1. depending on the key structure it is possible for the trie to be very unbalanced.  for a three byte
 *        key, for example, if 24 keys are inserted, each with only one different bit set, then the resulting
 *        trie would be a string of branch nodes extending to the left, each with a data node on its right
 *        branch.  the maximum trie depth would be 24 with the key of all zeros.
 *
 *     2. for the N node trie with b bit keys, even for very long keys, the average search requires log2(N)
 *        bit comparisons, and the average trie depth is log2(N).  see reference 1.  for a full key space,
 *        N = 2**b, log2(2**b) = b, and the average trie depth approaches b.
 *
 *     3. note that insertion requires two traversals of the trie - one to find if the key(s) already exists
 *        and the other to do the actual insertion.  the user may think that there must be a way to traverse
 *        down the trie only once to do an insertion.  the answer is YES! But.  in order to know where to
 *        stop you need to know all the key bits that intervene between the two b bit parameters of each
 *        branch node.  thus you would have to store these bits in each branch node or you could store any
 *        full key from any data node below a branch node in that branch node, which, by the property of a
 *        PATRICIA trie, will all have prefix bits identical for all data nodes below that branch node.  if,
 *        on insertion, the insertion key had bits differing between the two b bit parameters of two branch
 *        nodes then an insertion would be done at that point.  all this key storage and bit comparison in
 *        each traversed branch node is inefficient.  the first search traversal finds the key that does not
 *        match, but this key has all the key bits needed to find the first key bit of the new key that is
 *        different from the nearest key already in the trie.  this first differing bit then tells the second
 *        traversal where to stop and insert the new key.  thus, dual traversal is more efficient and simpler.
 *
 *======================================================================================================================
 *
 * References:
 *
 *     1. Algorithms in C++ Third Edition Parts 1-4, Robert Sedgewick with Christopher J. Van Wyk,
 *        Addison-Wesley, 1998, Chapter 15.3 Patricia Tries, pp. 637.
 *
 *     2. PATRICIA - Practical Algorithm To Retrieve Information Coded in Alphanumeric, Donald R. Morrison,
 *        Journal of the Association for Computing Machinery, Vol. 15, No. 4, Oct. 1968, pp. 514-534.
 *
 *     3. The Art of Computer Programming: Sorting and Searching, Donald E. Knuth,
 *        Addison-Wesley, 1973, pp 490-499.
 *
 *======================================================================================================================
 *
 * Author: Richard Hogaboom
 *         richard.hogaboom@gmail.com
 *
 *======================================================================================================================
 */

#include <vector>
#include <string>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <cstring>

using std::vector;
using std::string;
using std::cerr;
using std::ofstream;

namespace MultiKeyRdxPat
{
    //#define DEBUG  // comment in to get DEBUG info

    // verify_mode arg to verify()
    typedef enum verify_mode
    {
        ERR_CODE,            // return 0 for no error and positive int with error code for any errors
        ERR_CODE_PRINT       // return same error code above but also print current data structure data
                             // node addresses/keys, branch node addresses and error messages
    } VERIFY_MODE;

    template <typename app_data> class MKRdxPat
    {
        private:

            //
            // typedefs
            //

            // branch node typedef
            typedef struct bnode
            {
                unsigned int id;     // IDentification(id=0 branch node,id=1 data node) - must be first field in node
                unsigned int br;     // br=0: from left parent BRanch - br=1: from right parent BRanch
                void *p;             // ptr to Parent node
                unsigned int nsn;    // Node Sequence Number - 0->max_rdx_nodes_
                unsigned int b;      // Bit number to do branch test on(bits start at 0 from right to left)
                void *l, *r;         // Left and Right node ptrs
            } BNODE;

            // data node typedef for application declarations.  the key must have one extra byte from max_key_bytes_
            // specified above in order to have an "impossible" key data node set at initialization
            typedef struct dnode
            {
                unsigned int id;     // IDentification(id=1) for data node - must be first field in node
                unsigned int *br;    // br=0: from left parent BRanch - br=1: from right parent branch - br[num_keys_]
                BNODE **p;           // ptr to Parent node - p[num_keys_]
                unsigned int nsn;    // Node Sequence Number - 0->max_rdx_nodes_
                void *nnfp;          // Next Node Free Ptr
                unsigned int alloc;  // 1 - allocated in rdx trie, 0 - on free queue
                unsigned char *key;  // search KEY(s) - key[num_keys_][1+max_key_bytes_]
                app_data data;       // user defined data structure
            } DNODE;

            // typedef of struct for PATRICIA node holding max_rdx_nodes_ data
            // nodes with num_keys_ keys of length max_key_bytes_
            typedef struct pnode
            {
                // rdx trie size in bytes - includes all data and branch nodes including the root node
                unsigned int bsize;

                // total number of nodes allocated(does not include root(0xff key) node)
                unsigned int alloc_nodes;

                // head of rdx search node trie for each key
                BNODE **head;  // BNODE *head[num_keys_]

                // array holding ptrs to app_data used in sort()
                app_data **app_data_ptrs;  // app_data *app_data_ptrs[max_rdx_nodes_+1]

                // number of ptrs in node_ptrs array(not including root node)
                unsigned int app_data_ptrs_cnt;

                // branch nodes and free queue head ptr(s) of branch nodes
                BNODE *bnodes;  // BNODE bnodes[max_rdx_nodes_+1][num_keys_]
                BNODE **bfree_head;  // BNODE *bfree_head[num_keys_]

                // data nodes and free queue head ptr of data nodes
                DNODE *dnodes;  // DNODE dnodes[max_rdx_nodes_+1]
                DNODE *dfree_head;
            } PNODE_;


            //
            // private data
            //

            const int max_rdx_nodes_;
            const int num_keys_;
            const int max_key_bytes_;

            // variables related to insert()
            BNODE **insert_p_, **insert_bna_;  // BNODE *insert_p_[num_keys_], *insert_bna_[num_keys_];
            unsigned int *insert_lr_;          // unsigned int insert_lr_[num_keys_];
            unsigned int *insert_key_bit_;     // unsigned int insert_key_bit_[num_keys_];
            BNODE **insert_c_;                 // BNODE *insert_c_[num_keys_];
            unsigned char *insert_ky_;         // unsigned char insert_ky_[num_keys_][1+max_key_bytes_];

            // variables related to search()
            BNODE *search_c_;           // BNODE *search_c_[num_keys_];
            unsigned char *search_ky_;  // unsigned char search_ky_[num_keys_][1+max_key_bytes_];

            // variables related to remove()
            BNODE *remove_c_;           // BNODE *remove_c_[num_keys_];
            unsigned char *remove_ky_;  // unsigned char remove_ky_[num_keys_][1+max_key_bytes_];

            // variables related to print()
            unsigned char *print_ky_;  // unsigned char print_ky_[1+max_key_bytes_];

            // variables related to verify()
            unsigned long *verify_bnode_addrs_;       // unsigned long verify_bnode_addrs_[num_keys_][max_rdx_nodes_+1];
            unsigned long *verify_free_bnode_addrs_;  // unsigned long verify_free_bnode_addrs_[num_keys_][max_rdx_nodes_+1];
            unsigned long *verify_dnode_addrs_;       // unsigned long verify_dnode_addrs_[max_rdx_nodes_+1];
            unsigned long *verify_free_dnode_addrs_;  // unsigned long verify_free_dnode_addrs_[max_rdx_nodes_+1];
            unsigned char *verify_dnode_keys_;        // unsigned char verify_dnode_keys_[num_keys_][max_rdx_nodes_+1][max_key_bytes_];
            unsigned long *verify_node_index_;        // unsigned long verify_node_index_[2][max_rdx_nodes_+1];

            // full trie calloc() free pointer
            void *free_ptr_;

            // primary data structure
            PNODE_ rdx_;


            //
            // private functions
            //

            // given a key and bit number (bits numbered 0 from right) will return that bit
            // used by: insert(), search(), remove(), print()
                unsigned int
            gbit
                (
                    unsigned char *key,
                    unsigned int bit_num
                )
            {
                unsigned int byte;
                unsigned int bit;
                unsigned char mask;

                // the byte index set here assumes one extra prefix byte in the input parameter key(for the
                // 0xff of the root node impossible key). thus, data nodes with keys of max_key_bytes_ will
                // have a 0 byte prefix added, and the byte index set here is not 0 to max_key_bytes_ but 1
                // to max_key_bytes_+1. e.g. if max_key_bytes_=1 and bit_num=0 then byte is set to 1 not 0.
                // if max_key_bytes_=16 and bit_num=0 then byte is set to 16 not 15.
                mask = 1;
                byte = max_key_bytes_ - bit_num/8;
                mask <<= bit_num%8;
                bit = key[byte] & mask;
                bit >>= bit_num%8;

                return bit;
            }  // gbit()

            // recursive routine to descend rdx_ trie
            // used by: sort()
                void
            recursive
                (
                    BNODE *bnode_ptr
                )
            {
                // bnode_ptr is NULL only at end of trie traversal
                if ( bnode_ptr == NULL )
                {
                    return;
                }

                // if branch node continue down trie.  if data node inc count and store node ptr
                if ( bnode_ptr->id != 1 )
                {
                    recursive( (BNODE *)(bnode_ptr->l) );
                    recursive( (BNODE *)(bnode_ptr->r) );
                }
                else
                {
                    rdx_.app_data_ptrs[rdx_.app_data_ptrs_cnt++] = &( ((DNODE *)(bnode_ptr))->data );
                }
            }  // recursive()

            // used to compare node addresses stored in unsigned longs
            // used by: verify()
                static int
            unsigned_long_compare
                (
                    const void *a,
                    const void *b
                )
            {
                if ( *(unsigned long *)a < *(unsigned long *)b )
                {
                    return -1;
                }
                else if ( *(unsigned long *)a > *(unsigned long *)b )
                {
                    return 1;
                }

                return 0;
            }  // unsigned_long_compare()

            /*
             *======================================================================================================================
             *     initialize()
             *
             * Purpose: 
             *     Initialize the defined PNODE_ data structure.  This includes setting the data and branch node sequence
             *     numbers and data node allocated status(to 0).  Set total allocated nodes to 0, and allocated status of
             *     root node to 1.  Set the branch node free list up for each key and the data node free list.
             *
             * Usage:
             *     initialize();
             *
             * Returns:
             *     None
             *
             * Parameters:
             *     None
             *
             * Comments:
             *     1. remember that the data structure has 1+max_rdx_nodes_ nodes(each of which has one data and
             *        num_keys_ branch nodes).  the first is the always allocated impossible key root node.  the rest
             *        are the max_rdx_nodes_ user usable nodes.
             *
             *     2. certain pointers in the root node, such as parent pointers, are set to zero and permanently
             *        remain so since they have nothing to point to.  in root node printouts they should be zero.
             */

                void
            initialize
                (
                )
            {
                // set data and branch node sequence numbers and node allocated status
                for ( int n = 0 ; n < max_rdx_nodes_+1 ; n++ )
                {
                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        rdx_.bnodes[n*num_keys_+k].nsn = n;
                    }

                    rdx_.dnodes[n].nsn = n;
                    rdx_.dnodes[n].alloc = 0;
                }
                rdx_.dnodes[0].alloc = 1;  // root impossible key(0xff) node

                // reset total allocated nodes
                rdx_.alloc_nodes = 0;

                // for each key set various branch/data/head fields and pointers
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // set rdx trie head pointer(s)
                    rdx_.head[k] = &(rdx_.bnodes[0*num_keys_+k]);

                    // init head branch node
                    rdx_.bnodes[0*num_keys_+k].id = 0;
                    rdx_.bnodes[0*num_keys_+k].br = 0;
                    rdx_.bnodes[0*num_keys_+k].p = NULL;
                    rdx_.bnodes[0*num_keys_+k].b = max_key_bytes_*8;
                    rdx_.bnodes[0*num_keys_+k].l = &rdx_.dnodes[0];
                    rdx_.bnodes[0*num_keys_+k].r = NULL;

                    // build the branch node free list
                    rdx_.bfree_head[k] = &(rdx_.bnodes[1*num_keys_+k]);
                    for ( int n = 1 ; n < max_rdx_nodes_ ; n++ )
                    {
                        rdx_.bnodes[n*num_keys_+k].id = 0;
                        rdx_.bnodes[n*num_keys_+k].br = 0;
                        rdx_.bnodes[n*num_keys_+k].p = &rdx_.bnodes[(n+1)*num_keys_+k];
                        rdx_.bnodes[n*num_keys_+k].b = 0;
                        rdx_.bnodes[n*num_keys_+k].l = NULL;
                        rdx_.bnodes[n*num_keys_+k].r = NULL;
                    }
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].id = 0;
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].br = 0;
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].p = NULL;
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].b = 0;
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].l = NULL;
                    rdx_.bnodes[max_rdx_nodes_*num_keys_+k].r = NULL;

                    // init data node fields
                    for ( int n = 0 ; n < max_rdx_nodes_+1 ; n++ )
                    {
                        rdx_.dnodes[n].br[k] = 0;
                        rdx_.dnodes[n].p[k] = 0;
                        memset( &rdx_.dnodes[n].key[k*(1+max_key_bytes_)], 0, max_key_bytes_+1 );
                    }

                    // set data node parent pointers of root node to branch nodes for each key
                    rdx_.dnodes[0].p[k] = &rdx_.bnodes[0*num_keys_+k];

                    // init head data node key to impossible value, (the extra high order 0xff byte).
                    memset( &rdx_.dnodes[0].key[k*(1+max_key_bytes_)], 0xff, max_key_bytes_+1 );
                }

                // build the data node free list - use DNODE nnfp as pointer to next node
                rdx_.dnodes[0].id = 1;

                rdx_.dfree_head = &rdx_.dnodes[1];

                for ( int n = 1 ; n < max_rdx_nodes_ ; n++ )
                {
                    rdx_.dnodes[n].nnfp = (BNODE *)(&rdx_.dnodes[n+1]);
                    rdx_.dnodes[n].id = 1;
                }
                rdx_.dnodes[max_rdx_nodes_].nnfp = NULL;
                rdx_.dnodes[max_rdx_nodes_].id = 1;
            }  // initialize()

        public:
            MKRdxPat( int mnrn, int nk, int nkb ) : max_rdx_nodes_(mnrn), num_keys_(nk), max_key_bytes_(nkb)
            {
                unsigned char *fptr;  // free pointer


                if ( max_rdx_nodes_ < 1 )
                {
                    cerr << "max_rdx_nodes_ = " << max_rdx_nodes_ << "(must be > 0)" << "\n";
                    throw "max_rdx_nodes_ < 1(must be > 0)";
                }

                if ( num_keys_ < 1 )
                {
                    cerr << "num_keys_ = " << num_keys_ << "(must be > 0)" << "\n";
                    throw "num_keys_ < 1(must be > 0)";
                }

                if ( max_key_bytes_ < 1 )
                {
                    cerr << "max_key_bytes_ = " << max_key_bytes_ << "(must be > 0)" << "\n";
                    throw "max_key_bytes_ < 1(must be > 0)";
                }

                rdx_.bsize = 0;

                //
                // total calloc() segments =
                //     5(in PNODE_) +
                //     ( max_rdx_nodes_+1 ) * 3(in DNODE) +
                //     6(in insert()) +
                //     2(in search()) +
                //     2(in remove()) +
                //     1(in print()) +
                //     6(in verify())
                //

                // 5(in PNODE_)
                rdx_.bsize += (num_keys_) * sizeof(BNODE *) +                     // BNODE *head[num_keys_]
                              (max_rdx_nodes_+1) * sizeof(app_data *) +           // app_data *app_data_ptrs[max_rdx_nodes_+1]
                              ((max_rdx_nodes_+1) * num_keys_) * sizeof(BNODE) +  // BNODE bnodes[max_rdx_nodes_+1][num_keys_]
                              (num_keys_) * sizeof(BNODE *) +                     // BNODE *bfree_head[num_keys_]
                              (max_rdx_nodes_+1) * sizeof(DNODE);                 // DNODE dnodes[max_rdx_nodes_+1]

                // ( max_rdx_nodes_+1 ) * 3(in DNODE)
                for ( int i = 0 ; i < max_rdx_nodes_+1 ; i++ )
                {
                    rdx_.bsize += (num_keys_) * sizeof(unsigned int) +                       // unsigned int br[num_keys_]
                                  (num_keys_) * sizeof(BNODE *) +                            // BNODE *p[num_keys_]
                                  (num_keys_ * (1+max_key_bytes_)) * sizeof(unsigned char);  // unsigned char key[num_keys_][1+max_key_bytes_]
                }

                // 6(in insert())
                rdx_.bsize += num_keys_ * sizeof(BNODE *) +                            // BNODE *insert_p_[num_keys_]
                              num_keys_ * sizeof(BNODE *) +                            // BNODE *insert_bna_[num_keys_]
                              num_keys_ * sizeof(unsigned int) +                       // unsigned int insert_lr_[num_keys_]
                              num_keys_ * sizeof(unsigned int) +                       // unsigned int insert_key_bit_[num_keys_]
                              num_keys_ * sizeof(BNODE *) +                            // BNODE *insert_c_[num_keys_]
                              num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);  // unsigned char insert_ky_[num_keys_][1+max_key_bytes_]

                // 2(in search())
                rdx_.bsize += num_keys_ * sizeof(BNODE *) +                            // BNODE *search_c_[num_keys_];
                              num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);  // unsigned char search_ky_[num_keys_][1+max_key_bytes_]

                // 2(in remove())
                rdx_.bsize += num_keys_ * sizeof(BNODE *) +                            // BNODE *remove_c_[num_keys_];
                              num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);  // unsigned char remove_ky_[num_keys_][1+max_key_bytes_]

                // 1(in print())
                rdx_.bsize += (1+max_key_bytes_) * sizeof(unsigned char);  // unsigned char print_ky_[1+max_key_bytes_];

                // 6(in verify())
                rdx_.bsize += num_keys_ * (max_rdx_nodes_+1) * sizeof(unsigned long) +                  // unsigned long verify_bnode_addrs_[num_keys_][max_rdx_nodes_+1];
                              num_keys_ * (max_rdx_nodes_+1) * sizeof(unsigned long) +                  // unsigned long verify_free_bnode_addrs_[num_keys_][max_rdx_nodes_+1];
                              (max_rdx_nodes_+1) * sizeof(unsigned long) +                              // unsigned long verify_dnode_addrs_[max_rdx_nodes_+1];
                              (max_rdx_nodes_+1) * sizeof(unsigned long) +                              // unsigned long verify_free_dnode_addrs_[max_rdx_nodes_+1];
                              num_keys_ * (max_rdx_nodes_+1) * max_key_bytes_ * sizeof(unsigned char) + // unsigned char verify_dnode_keys_[num_keys_][max_rdx_nodes_+1][max_key_bytes_];
                              2 * (max_rdx_nodes_+1) * sizeof(unsigned long);                           // unsigned long verify_node_index_[2][max_rdx_nodes_+1];

                fptr = (unsigned char *)calloc( rdx_.bsize, sizeof(unsigned char) );
                if ( fptr == NULL )
                {
                    cerr << "Allocation of trie memory failed - calloc()\n";
                    throw "Allocation of trie memory failed - calloc()";
                }

                free_ptr_ = (void *)fptr;


                // dynamic allocation for PNODE_
                rdx_.head = (BNODE **) fptr;
                fptr += (num_keys_) * sizeof(BNODE *);

                rdx_.app_data_ptrs = (app_data **) fptr;
                fptr += (max_rdx_nodes_+1) * sizeof(DNODE *);

                rdx_.bnodes = (BNODE *) fptr;
                fptr += ((max_rdx_nodes_+1) * num_keys_) * sizeof(BNODE);

                rdx_.bfree_head = (BNODE **) fptr;
                fptr += (num_keys_) * sizeof(BNODE *);

                rdx_.dnodes = (DNODE *) fptr;
                fptr += (max_rdx_nodes_+1) * sizeof(DNODE);


                // dynamic allocation for DNODE
                for ( int i = 0 ; i < max_rdx_nodes_+1 ; i++ )
                {
                    rdx_.dnodes[i].br = (unsigned int *) fptr;
                    fptr += (num_keys_) * sizeof(unsigned int);

                    rdx_.dnodes[i].p = (BNODE **) fptr;
                    fptr += (num_keys_) * sizeof(BNODE *);

                    rdx_.dnodes[i].key = (unsigned char *) fptr;
                    fptr += (num_keys_ * (1+max_key_bytes_)) * sizeof(unsigned char);
                }

                // dynamic allocation for insert()
                insert_p_ = (BNODE **) fptr;
                fptr += num_keys_ * sizeof(BNODE *);

                insert_bna_ = (BNODE **) fptr;
                fptr += num_keys_ * sizeof(BNODE *);

                insert_lr_ = (unsigned int *) fptr;
                fptr += num_keys_ * sizeof(unsigned int);

                insert_key_bit_ = (unsigned int *) fptr;
                fptr += num_keys_ * sizeof(unsigned int);

                insert_c_ = (BNODE **) fptr;
                fptr += num_keys_ * sizeof(BNODE *);

                insert_ky_ = (unsigned char *) fptr;
                fptr += num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);

                // dynamic allocation for search()
                search_c_ = (BNODE *) fptr;
                fptr += num_keys_ * sizeof(BNODE *);

                search_ky_ = (unsigned char *) fptr;
                fptr += num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);

                // dynamic allocation for remove()
                remove_c_ = (BNODE *) fptr;
                fptr += num_keys_ * sizeof(BNODE *);

                remove_ky_ = (unsigned char *) fptr;
                fptr += num_keys_ * (1+max_key_bytes_) * sizeof(unsigned char);

                // dynamic allocation for print()
                print_ky_ = (unsigned char *) fptr;
                fptr += (1+max_key_bytes_) * sizeof(unsigned char);

                // dynamic allocation for verify()
                verify_bnode_addrs_ = (unsigned long *) fptr;
                fptr += num_keys_ * (max_rdx_nodes_+1) * sizeof(unsigned long);

                verify_free_bnode_addrs_ = (unsigned long *) fptr;
                fptr += num_keys_ * (max_rdx_nodes_+1) * sizeof(unsigned long);

                verify_dnode_addrs_ = (unsigned long *) fptr;
                fptr += (max_rdx_nodes_+1) * sizeof(unsigned long);

                verify_free_dnode_addrs_ = (unsigned long *) fptr;
                fptr += (max_rdx_nodes_+1) * sizeof(unsigned long);

                verify_dnode_keys_ = (unsigned char *) fptr;
                fptr += num_keys_ * (max_rdx_nodes_+1) * max_key_bytes_ * sizeof(unsigned char);

                verify_node_index_ = (unsigned long *) fptr;
                fptr += 2 * (max_rdx_nodes_+1) * sizeof(unsigned long);

                initialize();
            }  // MKRdxPat()


            ~MKRdxPat()
            {
                free( (void *)free_ptr_ );
            }  // ~MKRdxPat()

            /*
             *======================================================================================================================
             *     insert()
             *
             * Purpose: 
             *     remove a data node from the free list in the PNODE_ data structure and insert this node into the trie with keys
             *     key[NUM_KEYS][1+MAX_KEY_BYTES].  the second subscript first byte for all keys(key[k][0]) is the key boolean.
             *     the key boolean should always be set to 1 since all keys are needed for insertion.  the actual key bytes
             *     (key[k][1 to MAX_KEY_BYTES]) follow the key boolean.  each key must be unique within it's key
             *     index(0 to NUM_KEYS-1).
             *
             * Usage:
             *     struct app_data
             *     {
             *         int data;
             *     }
             *
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES];
             *     app_data *app_datap;
             *     int return_code;
             *
             *     return_code = rdx->insert((unsigned char *)key, &app_datap);
             *
             * Returns:
             *     1. if insertion is successful then set return_code to 0 and set app_datap to point to app_data
             *     2. if any key is found to already exist then set return_code to 1 and set app_datap to point to app_data
             *     3. if no data nodes are on the free list then set return_code to 2 and set app_datap to NULL
             *     4. if any key boolean is not 1 set return_code to 3 and set app_datap to NULL
             *
             * Parameters:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES] - NUM_KEYS keys - one byte key boolean and MAX_KEY_BYTES key bytes
             *     app_data **app_datapp                        - pointer to pointer to the inserted data node app_data struct
             *                                                    or NULL if insertion fails
             *
             * Comments:
             */

                int
            insert
                (
                    unsigned char *key,  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
                    app_data **app_datapp
                )
            {
                // during search p[] and c[] are successively set to parent and child nodes down the trie.
                // if a new key is to be inserted bna will be the branch node address linked between p[] and c[]
                // and dna will be the data node address linked as the other child of bna.  num_keys_ branch nodes
                // are always added with one data node.  lr[k] is used to set the br indicator in all nodes - lr[k]=1:
                // node is a right link of its parent, lr[k]=0: node is a left link of its parent.  key_bit is the
                // leftmost bit that key is different from terminating key actually found in trie.

                // BNODE **p, **bna;  // BNODE *p[num_keys_], *bna[num_keys_];

                DNODE *dna;

                // unsigned int *lr;  // unsigned int lr[num_keys_];
                // unsigned int *key_bit;  // unsigned int key_bit[num_keys_];

                // c[] is declared as BNODE * but is cast to DNODE * at the end of a search.
                // this is because all searches go through a series of BNODES and end at a DNODE.
                // the determination of search termination is made by examining c[k]->id == 1,
                // which indicates a data node.  since c[k] is declared a BNODE * and the id
                // field is in both node types, then the id field must be at the start of the
                // typedef and in the same relative position in order to get the correct value.

                // BNODE **c;  // BNODE *c[num_keys_];

                // unsigned char *ky;  // unsigned char ky[num_keys_][1+max_key_bytes_];


                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // for insertion all key booleans must be 1
                    if ( key[k*(1+max_key_bytes_)+0] != 1 )
                    {
                        *app_datapp = NULL;
                        return 3;
                    }
                }

                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // copy key to storage with extra byte for comparison
                    insert_ky_[k*(1+max_key_bytes_)+0] = 0;
                    memmove( &insert_ky_[k*(1+max_key_bytes_)+1], &key[k*(1+max_key_bytes_)+1], max_key_bytes_ );

                    // search for key in rdx trie
                    insert_c_[k] = (BNODE *)(rdx_.head[k]->l);
                    while ( insert_c_[k]->id == 0 )
                    {
                        insert_c_[k] = ( gbit( &insert_ky_[k*(1+max_key_bytes_)], insert_c_[k]->b ) ) ? (BNODE *)(insert_c_[k]->r) : (BNODE *)(insert_c_[k]->l);
                    }

                    // if key found return node in arg and set return to 1
                    if ( memcmp( &insert_ky_[k*(1+max_key_bytes_)], &((DNODE *)insert_c_[k])->key[k*(1+max_key_bytes_)], max_key_bytes_+1 ) == 0 )
                    {
                        *app_datapp = &( ((DNODE *)(insert_c_[k]))->data );
                        return 1;
                    }
                }

                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // if no nodes free set app_datapp to NULL and return 2
                    if ( rdx_.bfree_head[k] == NULL || rdx_.dfree_head == NULL )
                    {
                        *app_datapp = NULL;
                        return 2;
                    }
                }

                dna = rdx_.dfree_head;
                rdx_.dfree_head = (DNODE *)(rdx_.dfree_head->nnfp);
                rdx_.alloc_nodes++;

                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // key not found in rdx trie: find leftmost bit that key is different from terminating
                    // key actually found in trie.
                    //
                    // NOTE: the extra high order byte should insure that any time we arrive at this code
                    //       ((DNODE *)c[k])->key[k] and key are different.  the maximum key bit will be the
                    //       first bit of the extra byte.  if the keys are not different before or at bit zero
                    //       (the furthest right most bit) then this statement will call gbit() with a negative
                    //       value of key_bit and a memory violation will probably result or at the very least
                    //       wholly incorrect insertion.
                    insert_key_bit_[k] = max_key_bytes_*8;
                    while ( gbit( &((DNODE *)insert_c_[k])->key[k*(1+max_key_bytes_)], insert_key_bit_[k] ) == gbit( &insert_ky_[k*(1+max_key_bytes_)+0], insert_key_bit_[k] ) )
                    {
                        insert_key_bit_[k]--;
                    }

                    // allocate new nodes from free list
                    insert_bna_[k] = rdx_.bfree_head[k];
                    rdx_.bfree_head[k] = (BNODE *)(rdx_.bfree_head[k]->p);

                    // search for location to insert new key - c[k]->id != 0 new node will be at external trie
                    // node insertion, insert_c_[k]->b <= insert_key_bit_ new node will be internal trie node insertion
                    insert_lr_[k] = 0;
                    insert_p_[k] = rdx_.head[k];
                    insert_c_[k] = (BNODE *)(rdx_.head[k]->l);
                    while ( insert_c_[k]->id == 0 && insert_c_[k]->b > insert_key_bit_[k] )
                    {
                        insert_p_[k] = insert_c_[k];
                        if ( gbit( &insert_ky_[k*(1+max_key_bytes_)+0], insert_c_[k]->b ) )
                        {
                            insert_c_[k] = (BNODE *)(insert_c_[k]->r);
                            insert_lr_[k] = 1;
                        }
                        else
                        {
                            insert_c_[k] = (BNODE *)(insert_c_[k]->l);
                            insert_lr_[k] = 0;
                        }
                    }

                    // set parent and child links to new branch node address
                    if ( insert_lr_[k] == 0 )
                    {
                        insert_p_[k]->l = insert_bna_[k];
                    }
                    else
                    {
                        insert_p_[k]->r = insert_bna_[k];
                    }

                    if ( insert_c_[k]->id == 0 )
                    {
                        ((BNODE *)insert_c_[k])->p = insert_bna_[k];
                    }
                    else
                    {
                        ((DNODE *)insert_c_[k])->p[k] = insert_bna_[k];
                    }

                    // set new branch node links and both child parent branches(dna->br[k],insert_c_[k]->br)
                    insert_bna_[k]->br = insert_lr_[k];
                    insert_bna_[k]->b = insert_key_bit_[k];
                    insert_bna_[k]->p = insert_p_[k];
                    if ( gbit( &insert_ky_[k*(1+max_key_bytes_)+0], insert_bna_[k]->b ) )
                    {
                        insert_bna_[k]->l = (void *)(insert_c_[k]);
                        insert_bna_[k]->r = (void *)(dna);
                        dna->br[k] = 1;
                        if ( insert_c_[k]->id == 0 )
                        {
                            ((BNODE *)insert_c_[k])->br = 0;
                        }
                        else
                        {
                            ((DNODE *)insert_c_[k])->br[k] = 0;
                        }
                    }
                    else
                    {
                        insert_bna_[k]->l = (void *)(dna);
                        insert_bna_[k]->r = (void *)(insert_c_[k]);
                        dna->br[k] = 0;
                        if ( insert_c_[k]->id == 0 )
                        {
                            ((BNODE *)insert_c_[k])->br = 1;
                        }
                        else
                        {
                            ((DNODE *)insert_c_[k])->br[k] = 1;
                        }
                    }

                    #ifdef DEBUG
                    printf("DEBUG-1: insert_ky_ k = %d\n", k);
                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("%X ", *(&insert_ky_[k*(1+max_key_bytes_)+0]+i) );
                    }
                    printf("\n");
                    #endif

                    // set child key
                    memmove( &(dna->key[k*(1+max_key_bytes_)]), &insert_ky_[k*(1+max_key_bytes_)], max_key_bytes_+1 );

                    #ifdef DEBUG
                    printf("DEBUG-2: dna->key[] k = %d\n", k);
                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("%X ", *( &(dna->key[k*(1+max_key_bytes_)])+i ) );
                    }
                    printf("\n\n");
                    #endif

                    // set back pointer
                    dna->p[k] = insert_bna_[k];
                }

                // set node to allocated status
                dna->alloc = 1;

                #ifdef DEBUG
                printf("DEBUG-3: dna = %p \n", (void *)dna );
                #endif

                // new node insertion successful, set return values
                *app_datapp = &( dna->data );

                #ifdef DEBUG
                printf("DEBUG-4: end insert(): %d\n", dna->id);
                #endif

                return 0;
            }  // insert()

            /*
             *======================================================================================================================
             *     search()
             *
             * Purpose: 
             *     search trie for the data node with the keys key[NUM_KEYS][1+MAX_KEY_BYTES].  the second subscript first byte
             *     for all keys(key[k][0]) is the key boolean.  the key boolean should be set to 1(use the key) or
             *     0(do not use key).  the actual key bytes(key[k][1 to max_key_bytes_]) follow the key boolean.  thus, 1 to
             *     num_keys_ keys may be used in any given search.  only one key is necessary to find the data node.  each key
             *     must be unique within it's key index(0 - NUM_KEYS-1).
             *
             * Usage:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES];
             *     app_data *app_datap;
             *
             *     app_datap = rdx->search((unsigned char *)key);
             *
             * Returns:
             *     1. if search is successful then return pointer to app_data(app_datap)
             *     2. if any key boolean is not 0 or 1 return NULL
             *     3. if two key searches end at different data nodes return NULL
             *     4. if any key search does not end at a data node return NULL
             *     5. if no key boolean is 1 then no keys are used and return NULL
             *    
             * Parameters:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES] - NUM_KEYS keys - one byte key boolean and MAX_KEY_BYTES key bytes
             *
             * Comments:
             *     e.g. set NUM_KEYS=3 and MAX_KEY_BYTES=4
             *
             *          example 1:
             *          in key[][]:
             *             key number  key
             *             0           01 aa bb cc dd    
             *             1           01 ee ee ee ee
             *             2           01 ff ff ff ff
             *
             *             use all three keys(0,1,2) in the search
             *
             *          example 2:
             *          in key[][]:
             *             0           00 aa bb cc dd
             *             1           01 ee ee ee ee
             *             2           00 ff ff ff ff
             *
             *             use only key 1 in the search
             *
             *          example 3:
             *          in key[][]:
             *             0           01 00 00 00 01
             *             1           01 00 00 00 01
             *             2           01 00 00 00 01
             *
             *             inserted successfuly - a. all key booleans 1  b. each key unique in it's own key index(0 - 2)
             */

                app_data *
            search
                (
                    unsigned char *key  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
                )
            {
                // c[] is declared as BNODE * but is cast to DNODE * at the end of a search.
                // this is because all searches go through a series of BNODES and end at a DNODE.
                // the determination of search termination is made by examining c[k]->id == 1,
                // which indicates a data node.  since c[k] is declared a BNODE * and the id
                // field is in both node types, then the id field must be at the start of the
                // typedef and in the same relative position in order to get the correct value.

                // BNODE *c;  // BNODE *c[num_keys_]

                BNODE *csav;

                // unsigned char *ky;  // unsigned char ky[num_keys_][1+max_key_bytes_];

                bool firsttime = true;  // every search() call


                int n = 0;
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    #ifdef DEBUG
                    printf("DEBUG-5: k = %d\n", k);
                    #endif

                    if ( key[k*(1+max_key_bytes_)+0] == 0 )
                    {
                        continue;  // if key boolean is 0 skip key
                    }
                    else if ( key[k*(1+max_key_bytes_)+0] == 1 )
                    {
                        n++;  // if key boolean is 1 use key
                    }
                    else
                    {
                        return NULL;  // if a key boolean is not 0 or 1
                    }

                    // copy key to storage with extra byte for comparison
                    search_ky_[k*(1+max_key_bytes_)+0] = 0;
                    memmove( &search_ky_[k*(1+max_key_bytes_)+1], &key[k*(1+max_key_bytes_)+1], max_key_bytes_ );

                    // search for key in rdx trie
                    search_c_ = (BNODE *)(rdx_.head[k]->l);
                    while ( search_c_->id == 0 )
                    {
                        search_c_ = ( gbit( &search_ky_[k*(1+max_key_bytes_)+0], search_c_->b ) ) ? (BNODE *)(search_c_->r) : (BNODE *)(search_c_->l);
                    }

                    #ifdef DEBUG
                    printf("DEBUG-6: search_c_ = %p \n", (void *)search_c_ );
                    printf("DEBUG-7: ((DNODE *)search_c_)->key = %p \n", (void *)((DNODE *)search_c_)->key );
                    #endif

                    // check if all keys end at the same data node - if not return NULL
                    if ( firsttime == true )
                    {
                        csav = search_c_;
                        firsttime = false;
                    }
                    else
                    {
                        if ( search_c_ != csav )
                        {
                            return NULL;  // a key does not end at the same data node as a previous key
                        }
                    }

                    #ifdef DEBUG
                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("%X ", *(&search_ky_[k*(1+max_key_bytes_)+0]+i) );
                    }
                    printf("\n");

                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("DEBUG-8: %p\n",  (void *)(&((DNODE *)search_c_)->key[k*(1+max_key_bytes_)]+i) );
                        printf("DEBUG-9: %X\n", *( &((DNODE *)search_c_)->key[k*(1+max_key_bytes_)]+i ) );
                    }
                    printf("\n");

                    printf("DEBUG-10: dna = %p\n", (void *)(DNODE *)search_c_ );
                    #endif

                    // if key not found return NULL
                    if ( memcmp( &search_ky_[k*(1+max_key_bytes_)+0], &((DNODE *)search_c_)->key[k*(1+max_key_bytes_)], max_key_bytes_+1 ) != 0 )
                    {
                        #ifdef DEBUG
                        printf("DEBUG-11: k = exit2\n");
                        #endif

                        return NULL;  // key not found
                    }
                }

                if ( n == 0 )
                {
                    #ifdef DEBUG
                    printf("DEBUG-12: k = exit3\n");
                    #endif

                    return NULL;  // no keys are used(all key booleans are 0)
                }

                // success - all keys found in the same data node - return data node pointer
                return &( ((DNODE *)(search_c_))->data );
            }  // search()

            /*
             *======================================================================================================================
             *     remove()
             *
             * Purpose: 
             *     remove trie data node with the keys key[NUM_KEYS][1+MAX_KEY_BYTES].  the second subscript first byte for all
             *     keys(key[k][0]) is the key boolean.  the key boolean should be set to 1(use the key) or 0(do not use key).
             *     the actual key bytes(key[k][1 to MAX_KEY_BYTES]) follow the key boolean.  thus, 1 to NUM_KEYS keys may be used
             *     for any given remove.  only one key is necessary to remove the data node.  each key must be unique within it's
             *     key index(0 - NUM_KEYS-1).
             *
             * Usage:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES];
             *     app_data *app_datap;
             *
             *     app_datap = rdx->remove((unsigned char *)key);
             *
             * Returns:
             *     1. if search is successful then return pointer to app_data(app_datap)
             *     2. if any key boolean is not 0 or 1 return NULL
             *     3. if two key searches end at different data nodes return NULL
             *     4. if any key search does not end at a data node return NULL
             *     5. if no key boolean is 1 then no keys are used and return NULL
             *
             * Parameters:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES] - NUM_KEYS keys - one byte key boolean and MAX_KEY_BYTES key bytes
             *
             * Comments:
             *     e.g. set NUM_KEYS=3 and MAX_KEY_BYTES=4
             *
             *          example 1:
             *          in key[][]:
             *             key number  key
             *             0           01 aa bb cc dd    
             *             1           01 ee ee ee ee
             *             2           01 ff ff ff ff
             *
             *             use all three keys(0,1,2) in the search
             *
             *          example 2:
             *          in key[][]:
             *             0           00 aa bb cc dd
             *             1           01 ee ee ee ee
             *             2           00 ff ff ff ff
             *
             *             use only one key(1) in the search
             */

                app_data *
            remove
                (
                    unsigned char *key  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
                )
            {
                int n;

                // other child pointer
                BNODE *oc;

                // c[] is declared as BNODE * but is cast to DNODE * at the end of a search.
                // this is because all searches go through a series of BNODES and end at a DNODE.
                // the determination of search termination is made by examining c[k]->id == 1,
                // which indicates a data node.  since c[k] is declared a BNODE * and the id
                // field is in both node types, then the id field must be at the start of the
                // typedef and in the same relative position in order to get the correct value.

                // BNODE *c;  // BNODE *c[num_keys_]

                BNODE *csav;

                // unsigned char *ky;  // unsigned char ky[num_keys_][1+max_key_bytes_];

                bool firsttime = true;  // every remove() call


                n = 0;
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    #ifdef DEBUG
                    printf("DEBUG-13: key boolean = %X\n", key[k*(1+max_key_bytes_)+0]);
                    #endif

                    if ( key[k*(1+max_key_bytes_)+0] == 0 )
                    {
                        continue;
                    }
                    else if ( key[k*(1+max_key_bytes_)+0] == 1 )
                    {
                        n++;  // if key boolean is 1 use key
                    }
                    else
                    {
                        #ifdef DEBUG
                        printf("DEBUG-14: k = exit0\n");
                        #endif

                        return NULL;  // if a key boolean is not 0 or 1
                    }

                    #ifdef DEBUG
                    printf("DEBUG-15: k = %d\n", k);
                    printf("DEBUG-16: max_rdx_nodes_ = %d\n", max_rdx_nodes_);
                    printf("DEBUG-17: num_keys_ = %d\n", num_keys_);
                    printf("DEBUG-18: max_key_bytes_ = %d\n", max_key_bytes_);
                    #endif


                    // copy key to storage with extra byte for comparison
                    remove_ky_[k*(1+max_key_bytes_)+0] = 0;
                    memmove( &remove_ky_[k*(1+max_key_bytes_)+1], &key[k*(1+max_key_bytes_)+1], max_key_bytes_ );

                    // search for key in rdx trie
                    remove_c_ = (BNODE *)(rdx_.head[k]->l);
                    while ( remove_c_->id == 0 )
                    {
                        remove_c_ = ( gbit( &remove_ky_[k*(1+max_key_bytes_)+0], remove_c_->b ) ) ? (BNODE *)(remove_c_->r) : (BNODE *)(remove_c_->l);
                    }

                    // check if all keys end at the same data node - if not return NULL
                    if ( firsttime == true )
                    {
                        csav = remove_c_;
                        firsttime = false;
                    }
                    else
                    {
                        if ( remove_c_ != csav )
                        {
                            return NULL;  // a key does not end at the same data node as a previous key
                        }
                    }

                    #ifdef DEBUG
                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("DEBUG-19: %X ", *(&remove_ky_[k*(1+max_key_bytes_)+0]+i) );
                    }
                    printf("\n");

                    for ( int i = 0 ; i < max_key_bytes_+1 ; i++ )
                    {
                        printf("DEBUG-20: %p\n",  (void *)(&((DNODE *)remove_c_)->key[k*(1+max_key_bytes_)]+i) );
                        printf("DEBUG-21: %X\n", *( &((DNODE *)remove_c_)->key[k*(1+max_key_bytes_)]+i ) );
                    }
                    printf("\n");
                    #endif

                    // if key not found return NULL
                    if ( memcmp( &remove_ky_[k*(1+max_key_bytes_)+0], &((DNODE *)remove_c_)->key[k*(1+max_key_bytes_)], max_key_bytes_+1 ) != 0 )
                    {
                        return NULL;  // key not found
                    }
                }

                if ( n == 0 )
                {
                    #ifdef DEBUG
                    printf("DEBUG-22: k = exit3\n");
                    #endif

                    return NULL;  // no keys are used(all key booleans are 0)
                }

                // for each key reset pointers for num_keys_ branch nodes and the data node
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // set ptr to other child of branch node to remove
                    if ( ((DNODE *)remove_c_)->br[k] == 0 )
                    {
                        oc = ((BNODE *)((BNODE *)((DNODE *)remove_c_)->p[k])->r);
                    }
                    else
                    {
                        oc = ((BNODE *)((BNODE *)((DNODE *)remove_c_)->p[k])->l);
                    }

                    if ( oc->id == 0 )
                    {
                        // other child is a branch node - repair other child ptrs
                        ((BNODE *)oc)->p = ((BNODE *)((DNODE *)remove_c_)->p[k])->p;
                        ((BNODE *)oc)->br = ((BNODE *)((DNODE *)remove_c_)->p[k])->br;
                    }
                    else
                    {
                        // other child is a data node - repair other child ptrs
                        ((DNODE *)oc)->p[k] = ((BNODE*)((BNODE *)((DNODE *)remove_c_)->p[k])->p);
                        ((DNODE *)oc)->br[k] = ((BNODE *)((DNODE *)remove_c_)->p[k])->br;
                    }

                    // repair ptr of parent of parent
                    if ( ((BNODE *)((DNODE *)remove_c_)->p[k])->br == 0 )
                    {
                        ((BNODE *)((BNODE *)((DNODE *)remove_c_)->p[k])->p)->l = oc;
                    }
                    else
                    {
                        ((BNODE *)((BNODE *)((DNODE *)remove_c_)->p[k])->p)->r = oc;
                    }

                    // return branch nodes to free list
                    ((BNODE *)((DNODE *)remove_c_)->p[k])->p = rdx_.bfree_head[k];
                    rdx_.bfree_head[k] = ((DNODE *)remove_c_)->p[k];
                }

                // set node to free status
                ((DNODE *)remove_c_)->alloc = 0;

                // return data node to free list
                ((DNODE *)remove_c_)->nnfp = rdx_.dfree_head;
                rdx_.dfree_head = (DNODE *)remove_c_;

                // decrement total allocated nodes
                rdx_.alloc_nodes--;

                // set return pointer to removed node app_data
                return &( ((DNODE *)(remove_c_))->data );
            }  // remove()

            /*
             *======================================================================================================================
             *     sort()
             *
             * Purpose: 
             *     sort pointers to app_data (app_data *app_data_ptrs[max_rdx_nodes_+1]) by key index k in key ascending order
             *
             * Usage:
             *     app_data **app_datapp;
             *     int k;
             *     int return_code;
             *
             *     return_code = rdx->sort(&app_datapp, k);
             *
             * Returns:
             *     1. return_code set to the number of sorted nodes and app_data **app_datapp pointer
             *        set to array of pointers to app_data
             *     2. if there are no data nodes(no keys to sort) return 0 and set
             *        app_data **app_datapp to NULL
             *     3. if k, the key index, is out of range(0 - NUM_KEYS-1) return -1 and set
             *        app_data **app_datapp to NULL
             *
             * Parameters:
             *     app_data ***app_data - pointer to pointer to pointer to app_data
             *     int k                - key index(0 - NUM_KEYS-1)
             *
             * Comments:
             *     ((app_data *)app_datapp[0 to return_code-1])->(app_data struct fields) - to access app_data data
             *
             */

                int
            sort
                (
                    app_data ***app_datappp,
                    int k
                )
            {
                if ( k < 0 || k > num_keys_-1 )
                {
                    *app_datappp = NULL;
                    return -1;
                }

                // set full node_ptrs array to 0xf0 - shouldn't affect anything - then 0xf0 pattern
                // will be in array elements not allocated - makes debugging easier
                memset( rdx_.app_data_ptrs, 0xf0, (max_rdx_nodes_+1) * sizeof(app_data *) );

                rdx_.app_data_ptrs_cnt = 0;

                recursive( rdx_.head[k] );

                *app_datappp = rdx_.app_data_ptrs;

                if ( rdx_.app_data_ptrs_cnt-1 == 0 )
                {
                    *app_datappp = NULL;
                }

                return rdx_.app_data_ptrs_cnt-1;
            }  // sort()

            /*
             *======================================================================================================================
             *     alloc_nodes()
             *
             * Purpose: 
             *     return the number of allocated data nodes in the trie.
             *
             * Usage:
             *     int alloc_nodes;
             *
             *     alloc_nodes = rdx->alloc_nodes();
             *
             * Returns:
             *     1. int alloc_nodes - number of allocated nodes in the trie(0 - MAX_RDX_NODES)
             *
             * Parameters:
             *     None
             *
             * Comments:
             *     the number of actual nodes in the trie is MAX_RDX_NODES+1.  the extra node is the always allocated impossible
             *     key node with key(s) 0xff.  the maximum number of user available nodes is MAX_RDX_NODES.  this function
             *     returns only the number of user allocated nodes in the trie.
             */

                int
            alloc_nodes
                (
                )
            {
               return rdx_.alloc_nodes;
            }  // alloc_nodes()

            /*
             *======================================================================================================================
             *     bsize()
             *
             * Purpose: 
             *     return the size in bytes of the trie
             *
             * Usage:
             *     int bsize;
             *
             *     bsize = rdx->bsize();
             *
             * Returns:
             *     1. int bsize - the size in bytes of the trie
             *
             * Parameters:
             *     None
             *
             * Comments:
             *     rdx trie size in bytes - includes all data and branch nodes including the root node
             */

                int
            bsize
                (
                )
            {
               return rdx_.bsize;
            }  // bsize()

            /*
             *======================================================================================================================
             *     max_rdx_nodes()
             *
             * Purpose: 
             *     return the maximum number of data nodes that may be allocated in the trie
             *
             * Usage:
             *     int max_rdx_nodes;
             *
             *     max_rdx_nodes = rdx->max_rdx_nodes();
             *
             * Returns:
             *     1. int max_rdx_nodes - maximum number of data nodes that may be allocated in the trie
             *
             * Parameters:
             *     None
             *
             * Comments:
             *     1. alloc_nodes() will always return 0 to max_rdx_nodes()
             */

                int
            max_rdx_nodes
                (
                )
            {
               return max_rdx_nodes_;
            }  // max_rdx_nodes()

            /*
             *======================================================================================================================
             *     num_keys()
             *
             * Purpose: 
             *     return the number of keys in the trie
             *
             * Usage:
             *     int num_keys;
             *
             *     num_keys = rdx->num_keys();
             *
             * Returns:
             *     1. int num_keys - the number of keys in the trie
             *
             * Parameters:
             *     None
             *
             * Comments:
             */

                int
            num_keys
                (
                )
            {
               return num_keys_;
            }  // num_keys()

            /*
             *======================================================================================================================
             *     max_key_bytes()
             *
             * Purpose: 
             *     return the maximum number of bytes in any of the num_keys_ keys
             *
             * Usage:
             *     int max_key_bytes;
             *
             *     max_key_bytes = rdx->max_key_bytes();
             *
             * Returns:
             *     1. int max_key_bytes - the maximum number of bytes in any of the num_keys_ keys
             *
             * Parameters:
             *     None
             *
             * Comments:
             */

                int
            max_key_bytes
                (
                )
            {
               return max_key_bytes_;
            }  // max_key_bytes()

            /*
             *======================================================================================================================
             *     chg_max_rdx_nodes()
             *
             * Purpose: 
             *     create a new copy object of type MKRdxPat<app_data> with a new max_rdx_nodes_ and the same copied data.
             *     the new max_rdx_nodes_ value may be equal to the number of currently allocated nodes or larger.  thus, the
             *     new object can be shrunk to the size of the current number of allocated data nodes or expanded without limit.  
             *
             * Usage:
             *     int new_max_rdx_nodes;
             *
             *     MKRdxPat<app_data> *rdx_new = rdx_old->chg_max_rdx_nodes(new_max_rdx_nodes);
             *
             * Returns:
             *     1. object of type MKRdxPat<app_data> containing the same data as the originating object with a new size limit
             *     2. if new_max_rdx_nodes is less than the number of currently allocated nodes then return NULL
             *     3. if any transfer of a data node from the originating MKRdxPat<app_data> object to the new
             *        MKRdxPat<app_data> object fails return NULL
             *
             * Parameters:
             *     int new_max_rdx_nodes - the new size, max_rdx_nodes_, of the returned object
             *
             * Comments:
             *     1. the originating object is not affected in any way
             */

                MKRdxPat<app_data> *
            chg_max_rdx_nodes
                (
                    int new_max_rdx_nodes
                )
            {
                if ( new_max_rdx_nodes < rdx_.alloc_nodes )
                {
                    return NULL;
                }

                MKRdxPat<app_data> *rdx = new MKRdxPat<app_data>(new_max_rdx_nodes, num_keys_, max_key_bytes_);

                // get size of app_data struct
                int datasize = sizeof( rdx_.dnodes[0].data );

                //pointer to app_data struct returned by an insert()
                app_data *app_datap;

                // allocate space for the keys for node insertion into the new object
                unsigned char *rdx_key = (unsigned char *) calloc( num_keys_ * (1+max_key_bytes_) , sizeof(unsigned char) );

                // loop over all data nodes in the originating MKRdxPat<app_data> object and copy the allocated data nodes.
                // not node 0 because this is the impossible root node which will already be in the new object upon creation
                for ( int node = 1, return_code = 0 ; node < 1+max_rdx_nodes_ ; node++ )
                {
                    // alloc=0 node not allocated, alloc=1 node allocated
                    if ( rdx_.dnodes[node].alloc == 1 )
                    {
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            rdx_key[k*(1+max_key_bytes_)+0] = 1;
                            memmove( &rdx_key[k*(1+max_key_bytes_)+1], &rdx_.dnodes[node].key[k*(1+max_key_bytes_)+1], max_key_bytes_ );
                        }

                        // insert node with same keys as old object
                        return_code = rdx->insert((unsigned char *)rdx_key, &app_datap);
                        if ( return_code != 0 )
                        {
                            return NULL;
                        }

                        // move app_data struct data to new node
                        memmove(app_datap, &rdx_.dnodes[node].data, datasize );
                    }
                }

                free(rdx_key);

                return rdx;
            }  // chg_max_rdx_nodes()

            /*
             *======================================================================================================================
             *     print()
             *
             * Purpose: 
             *     Used in two modes:
             *         a. the first arg is NULL
             *
             *            print all the data in branch and data nodes for the entire trie.  for each data node allocated there
             *            will be NUM_KEYS new branch nodes allocated.  thus, for n data nodes allocated, there will be n*NUM_KEYS
             *            branch nodes printed and n data nodes printed.  the path along branch nodes to data nodes is not
             *            demonstrated.  useful only for small tries for debugging purposes.
             *
             *         b. the first arg is an array of 'unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]' of an existing allocated
             *            data node
             *
             *            print the data node and each branch node for each key(1 - NUM_KEYS) that leads to the found data node.
             *            the application data is not printed, only the trie structure data.
             *
             *     Setting 'unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]':
             *
             *     the second subscript first byte for all keys(key[k][0]) is the key boolean.  the key boolean should be set to
             *     1(use the key) or 0(do not use key).  the actual key bytes(key[k][1 to MAX_KEY_BYTES]) follow the key boolean.
             *     thus, 1 to NUM_KEYS keys may be used.  only one key is necessary to find the data node.  each key must be unique
             *     within it's key index(0 - NUM_KEYS-1).
             *
             * Usage:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES];
             *     ofstream& os;
             *     int return_code;
             *
             *     return_code = rdx->print(NULL, os);
             *     return_code = rdx->print((unsigned char *)key, os);
             *
             * Returns:
             *     1. return_code = 0 on success
             *     2. return_code = 1 if data node for key[][] not found
             *
             * Parameters:
             *     unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES] - NUM_KEYS keys - one byte key boolean and MAX_KEY_BYTES key bytes
             *     ofstream& os                                 - output stream
             *
             * Comments:
             *     e.g. set NUM_KEYS=3 and MAX_KEY_BYTES=4
             *
             *          example 1:
             *          in key[][]:
             *             key number  key
             *             0           01 aa bb cc dd    
             *             1           01 ee ee ee ee
             *             2           01 ff ff ff ff
             *
             *             use all three keys(0,1,2) in the search
             *
             *          example 2:
             *          in key[][]:
             *             0           00 aa bb cc dd
             *             1           01 ee ee ee ee
             *             2           00 ff ff ff ff
             *
             *             use only one key(1) in the search
             */

                int
            print
                (
                    unsigned char *key,  // unsigned char key[NUM_KEYS][1+MAX_KEY_BYTES]
                    ofstream& os
                )
            {
                const int TMPSTR_SIZE = 256;
                char tmpstr[TMPSTR_SIZE];

                // unsigned char *ky;  // unsigned char ky[1+max_key_bytes_];

                BNODE *c;
                app_data *app_datap;


                if ( key == NULL )
                {
                    os << "==========\n\n"
                          "print(NULL, os) called with NULL first arg.\n\n"
                          "print all the data in branch and data nodes for the entire trie.  for each data node allocated there\n"
                          "will be num_keys_ new branch nodes allocated.  thus, for n data nodes allocated, there will be n*num_keys_\n"
                          "branch nodes printed and n data nodes printed.  the path along branch nodes to data nodes is not\n"
                          "demonstrated.  useful only for small tries for debugging purposes.\n\n"

                          "Total nodes allocated: " << rdx_.alloc_nodes << "  Number of keys: " << num_keys_ << "  Key length: " << max_key_bytes_ << "\n\n\n"
                          "NODE n\n\n"
                          "Branch Node Format:\n"
                          "  key = (key index into key array in data node)\n"
                          "  nsn = (node sequence number, 0-max_rdx_nodes_+1)\n"
                          "   id = (node id - 0 = branch node, 1 - data node)\n"
                          "  bna = (branch node address)\n"
                          "   br = (left/right branch of parent - 0 = left, 1 = right)\n"
                          "    p = (parent address)\n"
                          "    b = (PATRICIA key bit(0 on right) at which this branch node distinguishes keys)\n"
                          "    l = (address of left node child)\n"
                          "    r = (address of right node child)\n"
                          "\n"
                          "Data Node Format:\n"
                          "   id = (node id - 0 = branch node, 1 - data node)\n"
                          "  dna = (data node address)\n"
                          "   br = (left/right branch of parent - 0 = left, 1 = right)\n"
                          "    p = (parent address)\n"
                          "  nsn = (node sequence number, 0-max_rdx_nodes_+1)\n"
                          "alloc = (0-node not allocated, 1-node allocated)\n"
                          "key n = (hex key value)\n"
                          "      .\n"
                          "      .\n"
                          "      .\n\n\n";

                    for ( int n = 0 ; n < max_rdx_nodes_+1 ; n++ )
                    {
                        if ( rdx_.dnodes[n].alloc != 1 )
                        {
                            continue;
                        }

                        os << "NODE " << n << "\n\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "  key =", k);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "  nsn =", rdx_.bnodes[n*num_keys_+k].nsn);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "   id =", rdx_.bnodes[n*num_keys_+k].id);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "  bna =", (void *)&rdx_.bnodes[n*num_keys_+k]);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "   br =", rdx_.bnodes[n*num_keys_+k].br);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "    p =", (void *)rdx_.bnodes[n*num_keys_+k].p);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "    b =", rdx_.bnodes[n*num_keys_+k].b);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "    l =", (void *)rdx_.bnodes[n*num_keys_+k].l);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "    r =", (void *)rdx_.bnodes[n*num_keys_+k].r);
                            os << tmpstr;
                        }
                        os << "\n\n";

                        snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "   id =", rdx_.dnodes[n].id);
                        os << tmpstr << "\n";
                        snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "  dna =", (void *)&rdx_.dnodes[n]);
                        os << tmpstr << "\n";
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "   br =", rdx_.dnodes[n].br[k]);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "    p =", (void *)rdx_.dnodes[n].p[k]);
                            os << tmpstr;
                        }
                        os << "\n";

                        snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "  nsn =", rdx_.dnodes[n].nsn);
                        os << tmpstr << "\n";
                        snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "alloc =", rdx_.dnodes[n].alloc);
                        os << tmpstr << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "  key %2d = ", k);
                            os << tmpstr;
                            for ( int b = 0 ; b < max_key_bytes_ ; b++ )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "%02x ", rdx_.dnodes[n].key[k*(1+max_key_bytes_)+b+1]);
                                os << tmpstr;
                            }
                            os << "\n";
                        }

                        os << "\n";
                    }

                    return 0;
                }
                else
                {
                    os << "==========\n\n"
                          "print(key, os) called with key[][] first arg.\n\n"
                          "print the data node and each branch node for each key(1-num_keys_) that leads to the found data node.\n"
                                "the application data is not printed, only the trie structure data.  the number of branch nodes printed\n"
                                "is indeterminate; it depends on the order of the data node insertion.  as few as one branch node and\n"
                                "as many as n branch nodes(n being the total number of data nodes already inserted) could be printed.\n\n";

                    os << "Search for data node with key(s)(includes key boolean):\n";
                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "  key %2d = ", k);
                        os << tmpstr;
                        for ( int b = 0 ; b < 1+max_key_bytes_ ; b++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%02x ", key[k*(1+max_key_bytes_)+b]);
                            os << tmpstr;
                        }
                        os << "\n";
                    }
                    os << "\n";

                    os << "Branch Node Format:\n"
                          "  nsn = (node sequence number, 0-max_rdx_nodes_+1)\n"
                          "   id = (node id - 0 = branch node, 1 - data node)\n"
                          "  bna = (branch node address)\n"
                          "   br = (left/right branch of parent - 0 = left, 1 = right)\n"
                          "    p = (parent address)\n"
                          "    b = (PATRICIA key bit(0 on right) at which this branch node distinguishes keys)\n"
                          "    l = (address of left node child)\n"
                          "    r = (address of right node child)\n"
                          "\n"
                          "Data Node Format:\n"
                          "   id = (node id - 0 = branch node, 1 - data node)\n"
                          "  dna = (data node address)\n"
                          "   br = (left/right branch of parent - 0 = left, 1 = right)\n"
                          "    p = (parent address)\n"
                          "  nsn = (node sequence number, 0-max_rdx_nodes_+1)\n"
                          "alloc = (0-node not allocated, 1-node allocated)\n"
                          "key n = (hex key value)\n"
                          "      .\n"
                          "      .\n"
                          "      .\n\n\n";

                    if ( (app_datap = search(key)) == NULL )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "print():(file %s  line %d): Key not found.\n", __FILE__, __LINE__);
                        os << tmpstr;
                        return 1;
                    }

                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        // copy key to storage with extra byte for comparison
                        print_ky_[k*(1+max_key_bytes_)+0] = 0;
                        memmove( &print_ky_[k*(1+max_key_bytes_)+1], &key[k*(1+max_key_bytes_)+1], max_key_bytes_ );

                        os << "==========\n";
                        snprintf(tmpstr, sizeof(tmpstr), "  key %2d = ", k);
                        os << tmpstr;
                        for ( int b = 0 ; b < 1+max_key_bytes_ ; b++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%02x ", key[k*(1+max_key_bytes_)+b]);
                            os << tmpstr;
                        }
                        os << "\n\n";

                        c = (BNODE *)rdx_.head[k];
                        while ( c->id == 0 )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "  nsn = %d\n", c->nsn);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "   id = %d\n", c->id);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "  bna = %p\n", (void *)c);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "   br = %d\n", c->br);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "    p = %p\n", (void *)c->p);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "    b = %-3d\n", c->b);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "    l = %p\n", (void *)c->l);
                            os << tmpstr;
                            snprintf(tmpstr, sizeof(tmpstr), "    r = %p\n", (void *)c->r);
                            os << tmpstr;
                            os << "\n";

                            c = ( gbit( print_ky_, c->b ) ) ? (BNODE *)c->r : (BNODE *)c->l;
                        }

                        snprintf(tmpstr, sizeof(tmpstr), "   id = %d\n", ((DNODE *)c)->id);
                        os << tmpstr;
                        snprintf(tmpstr, sizeof(tmpstr), "%7s %18p\n", "  dna =", (void *)c);
                        os << tmpstr;
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18d  ", "   br =", ((DNODE *)c)->br[k]);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "%7s %18p  ", "    p =", (void *)((DNODE *)c)->p[k]);
                            os << tmpstr;
                        }
                        os << "\n";

                        snprintf(tmpstr, sizeof(tmpstr), "  nsn = %d\n", ((DNODE *)c)->nsn);
                        os << tmpstr;
                        snprintf(tmpstr, sizeof(tmpstr), "alloc = %d\n", ((DNODE *)c)->alloc);
                        os << tmpstr;
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "  key %2d = ", k);
                            os << tmpstr;
                            for ( int b = 0 ; b < 1+max_key_bytes_ ; b++ )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "%02x ", key[k*(1+max_key_bytes_)+b]);
                                os << tmpstr;
                            }
                            os << "\n";
                        }
                        os << "\n";
                    }

                    return 0;
                }
            }  // print()

            /*
             *======================================================================================================================
             *     verify()
             *
             * Purpose: 
             *     verify the integrity of a PNODE_ structure.  multiple tests are used to verify the integrity of all branch and
             *     data node structures.  the input parameter enum VERIFY_MODE may be set to either ERR_CODE, which will
             *     return an integer error code(1-25) for each of the possible detected errors, or ERR_CODE_PRINT, which will
             *     return the same numerical error code and print to ofstream& os a text error message and current data
             *     structure data node addresses/keys and branch node addresses as well.
             *
             * Usage:
             *     ofstream& os;
             *     int return_code;
             *
             *     return_code = rdx->verify(ERR_CODE, os);
             *     return_code = rdx->verify(ERR_CODE_PRINT, os);
             *
             * Returns:
             *     1. return_code = 0    - 0 if no error
             *     2. return_code = 1-25 - 1-25 for the various errors
             *
             * Parameters:
             *     VERIFY_MODE vm  - enum with possible values (ERR_CODE, ERR_CODE_PRINT)
             *     ofstream& os    - output stream
             *
             * Comments:
             *     all error messages have the verify() file name and line number included
             */

                int
            verify
                (
                    VERIFY_MODE vm,
                    ofstream& os
                )
            {
                const unsigned int FREE = 0;
                const unsigned int ALLOC = 1;

                const int TMPSTR_SIZE = 256;
                char tmpstr[TMPSTR_SIZE];

                int tot_free_nodes;
                int tot_alloc_nodes;


                // branch node and data node free list head pointers
                BNODE *bhead;
                DNODE *dhead;

                // holds all of the allocated branch node addresses
                // unsigned long verify_bnode_addrs_[num_keys_][max_rdx_nodes_+1]; -> verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n]

                // unsigned long *verify_bnode_addrs_;


                // holds all of the unallocated branch node addresses
                // unsigned long verify_free_bnode_addrs_[num_keys_][max_rdx_nodes_+1]; -> verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+n]

                // unsigned long *verify_free_bnode_addrs_;


                // holds all of the allocated data node addresses
                // unsigned long dnode_addrs[max_rdx_nodes_+1]; -> dnode_addrs[n]

                // unsigned long *dnode_addrs;


                // holds all of the unallocated data node addresses
                // unsigned long verify_free_dnode_addrs_[max_rdx_nodes_+1]; -> verify_free_dnode_addrs_[n]

                // unsigned long *verify_free_dnode_addrs_;


                // hold all of the allocated data node keys
                // unsigned char verify_dnode_keys_[num_keys_][max_rdx_nodes_+1][max_key_bytes_]; -> verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]

                // unsigned char *verify_dnode_keys_;


                // holds integer indexes(0 to max_rdx_nodes_) of free and allocated nodes
                // unsigned long verify_node_index_[2][max_rdx_nodes_+1]; -> verify_node_index_[i*(max_rdx_nodes_+1)+n]

                // unsigned long *verify_node_index_;


                // accumulate all the free and allocated branch and data node addresses, the node indexes on
                // each free/alloc node and the total number of free and allocated nodes
                tot_free_nodes = 0;
                tot_alloc_nodes = 0;
                for ( int n = 0 ; n < max_rdx_nodes_+1 ; n++ )
                {
                    if ( rdx_.dnodes[n].alloc == 0 )
                    {
                        verify_node_index_[FREE*(max_rdx_nodes_+1)+tot_free_nodes] = n;
                        verify_free_dnode_addrs_[tot_free_nodes] = (unsigned long)&rdx_.dnodes[n];
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+tot_free_nodes] = (unsigned long)&rdx_.bnodes[n*num_keys_+k];
                        }

                        tot_free_nodes++;
                    }
                    else
                    {
                        verify_node_index_[ALLOC*(max_rdx_nodes_+1)+tot_alloc_nodes] = n;
                        verify_dnode_addrs_[tot_alloc_nodes] = (unsigned long)&rdx_.dnodes[n];
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            verify_bnode_addrs_[k*(max_rdx_nodes_+1)+tot_alloc_nodes] = (unsigned long)&rdx_.bnodes[n*num_keys_+k];
                            memmove( &verify_dnode_keys_[(k*(max_rdx_nodes_+1)+tot_alloc_nodes)*max_key_bytes_+0], &rdx_.dnodes[n].key[k*(1+max_key_bytes_)+1], max_key_bytes_ );
                                   // verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]
                        }

                        tot_alloc_nodes++;
                    }
                }

                // print all of the free/alloc data structure addresses, node indexes and keys
                if ( vm == ERR_CODE_PRINT )
                {
                    os << "return_code = rdx->verify(ERR_CODE_PRINT, os);\n"
                          "Free Data Node Address(DNA)/Keys and Branch Node Addresses(BNAs)\n"
                          "node  DNA         BNA(s)  ";
                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "key = %-2d  ", k);
                        os << tmpstr;
                    }
                    os << "\n";

                    for ( int n = 0 ; n < tot_free_nodes ; n++ )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "%4ld  %08lx          ", verify_node_index_[FREE*(max_rdx_nodes_+1)+n], verify_free_dnode_addrs_[n]);
                        os << tmpstr;
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                           snprintf(tmpstr, sizeof(tmpstr), "  %08lx", verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+n]);
                            os << tmpstr;
                        }
                        os << "\n";
                    }
                    os << "\n";

                    os << "Allocated Data Node Address(DNA)/Keys and Branch Node Addresses(BNAs)\n"
                          "node  DNA         BNA(s)  ";
                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "key = %-2d  ", k);
                        os << tmpstr;
                    }
                    os << "\n";

                    for ( int n = 0 ; n < tot_alloc_nodes ; n++ )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "%4ld  %08lx          ", verify_node_index_[ALLOC*(max_rdx_nodes_+1)+n], verify_dnode_addrs_[n]);
                        os << tmpstr;
                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "  %08lx", verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n]);
                            os << tmpstr;
                        }
                        os << "\n";

                        for ( int k = 0 ; k < num_keys_ ; k++ )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "      key %-2d = ", k);
                            os << tmpstr;
                            for ( int b = 0 ; b < max_key_bytes_ ; b++ )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "%02x ", verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]);
                                os << tmpstr;
                            }
                            os << "\n";
                        }
                        os << "\n";
                    }
                }

                // check if certain root node values are initialized to zero - there will
                // be num_keys_ branch nodes and one data node in the root node - these
                // values should remain permanently invariant at zero
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    if ( rdx_.bnodes[0*num_keys_+k].id != 0 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 1): Root branch node with non-zero id - %d\n",
                                __FILE__, __LINE__, rdx_.bnodes[0*num_keys_+k].id);
                            os << tmpstr;
                        }
                        return 1;
                    }

                    if ( rdx_.bnodes[0*num_keys_+k].br != 0 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 2): Root branch node with non-zero br - %d\n",
                                __FILE__, __LINE__, rdx_.bnodes[0*num_keys_+k].br);
                            os << tmpstr;
                        }
                        return 2;
                    }

                    if ( rdx_.bnodes[0*num_keys_+k].p != 0 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 3): Root branch node with non-zero p - 0x%08lx\n",
                                __FILE__, __LINE__, (unsigned long)rdx_.bnodes[0*num_keys_+k].p);
                            os << tmpstr;
                        }
                        return 3;
                    }

                    if ( rdx_.bnodes[0*num_keys_+k].b != (unsigned int)max_key_bytes_*8 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 4): Root branch node with b not equal to"
                                        " max_key_bytes_*8 - %d\n",
                                __FILE__, __LINE__, rdx_.bnodes[0*num_keys_+k].b);
                            os << tmpstr;
                        }
                        return 4;
                    }

                    if ( rdx_.bnodes[0*num_keys_+k].r != 0 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 5): Root branch node with non-zero r - 0x%08lx\n",
                                __FILE__, __LINE__, (unsigned long)rdx_.bnodes[0*num_keys_+k].r);
                            os << tmpstr;
                        }
                        return 5;
                    }

                    for ( int b = 0 ; b < max_key_bytes_+1 ; b++ )
                    {
                        if ( rdx_.dnodes[0].key[k*(1+max_key_bytes_)+b] != 0xff )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 6): Root data node keys not all 0xff\n",
                                    __FILE__, __LINE__);
                                os << tmpstr;
                            }
                            return 6;
                        }
                    }
                }

                // save data node, free node, branch node and key node address queues(will be unsorted),
                // total number of free nodes and total number of allocated nodes
                for ( int n = 0 ; n < max_rdx_nodes_+1 ; n++ )
                {
                    if ( rdx_.dnodes[n].id != 1 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 7): Data node id not 1 in node sequence number %d\n",
                                __FILE__, __LINE__, n);
                            os << tmpstr;
                        }
                        return 7;
                    }

                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        if ( rdx_.bnodes[n*num_keys_+k].nsn != (unsigned int)n )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 8): Branch node sequence number of key index %d"
                                            " not valid - %d\n",
                                    __FILE__, __LINE__, k, rdx_.bnodes[n*num_keys_+k].nsn);
                                os << tmpstr;
                            }
                            return 8;
                        }
                    }

                    if ( rdx_.dnodes[n].nsn != (unsigned int)n )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 9): Data node sequence number not valid - %d\n",
                                __FILE__, __LINE__, rdx_.dnodes[n].nsn);
                            os << tmpstr;
                        }
                        return 9;
                    }

                    if ( rdx_.dnodes[n].alloc != 0 && rdx_.dnodes[n].alloc != 1 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 10): Data node allocated boolean not 0/1"
                                        " in node sequence number %d\n",
                                __FILE__, __LINE__, rdx_.dnodes[n].nsn);
                            os << tmpstr;
                        }
                        return 10;
                    }
                }

                // verify that the sum of free and allocated nodes is max_rdx_nodes_+1 nodes
                if ( (tot_alloc_nodes + tot_free_nodes) != max_rdx_nodes_+1 )
                {
                    if ( vm == ERR_CODE_PRINT )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 11): Total allocated nodes(%d) + free nodes(%d)"
                                    " not equal max_rdx_nodes_+1(%d)\n",
                            __FILE__, __LINE__, tot_alloc_nodes, tot_free_nodes, max_rdx_nodes_+1);
                        os << tmpstr;
                    }
                    return 11;
                }

                // verify that the tot_alloc_nodes equals rdx_.alloc_nodes
                if ( (unsigned int)tot_alloc_nodes != (rdx_.alloc_nodes+1) )
                {
                    if ( vm == ERR_CODE_PRINT )
                    {
                        snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 12): Total allocated nodes(%d)"
                                    " not equal rdx_.alloc_nodes(%d)\n",
                            __FILE__, __LINE__, tot_alloc_nodes, rdx_.alloc_nodes);
                        os << tmpstr;
                    }
                    return 12;
                }

                // sort data node address queue
                {
                    int n = 0;
                    vector<unsigned long> da;  // verify_dnode_addrs_[n]

                    for ( n = 0 ; n < tot_alloc_nodes ; n++ )
                    {
                        // unsigned long verify_dnode_addrs_[max_rdx_nodes_+1]; -> verify_dnode_addrs_[n]
                        unsigned long ul = verify_dnode_addrs_[n];
                        da.push_back(ul);
                    }

                    std::sort( da.begin(), da.end() );

                    n = 0;
                    for( vector<unsigned long>::iterator it = da.begin(); it != da.end(); ++it )
                    {
                        verify_dnode_addrs_[n] = *it;
                        n++;
                    }
                }

                // sort free node address queue
                {
                    int n = 0;
                    vector<unsigned long> fda;  // verify_free_dnode_addrs_[n]

                    for ( n = 0 ; n < tot_free_nodes ; n++ )
                    {
                        // unsigned long verify_free_dnode_addrs_[max_rdx_nodes_+1]; -> verify_free_dnode_addrs_[n]
                        unsigned long ul = verify_free_dnode_addrs_[n];
                        fda.push_back(ul);
                    }

                    std::sort( fda.begin(), fda.end() );

                    n = 0;
                    for( vector<unsigned long>::iterator it = fda.begin(); it != fda.end(); ++it )
                    {
                        verify_free_dnode_addrs_[n] = *it;
                        n++;
                    }
                }

                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    // sort key branch node address queue
                    {
                        int n = 0;
                        vector<unsigned long> ba;  // verify_bnode_addrs_[]

                        for ( n = 0 ; n < tot_alloc_nodes ; n++ )
                        {
                            // unsigned long verify_bnode_addrs_[num_keys_][max_rdx_nodes_+1]; -> verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n]
                            unsigned long ul = verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n];
                            ba.push_back(ul);
                        }

                        std::sort( ba.begin(), ba.end() );

                        n = 0;
                        for( vector<unsigned long>::iterator it = ba.begin(); it != ba.end(); ++it )
                        {
                            verify_bnode_addrs_[k*(max_rdx_nodes_+1)+n] = *it;
                            n++;
                        }
                    }

                    // sort key free branch node queue
                    {
                        int n = 0;
                        vector<unsigned long> fba;  // verify_free_bnode_addrs_[]

                        for ( n = 0 ; n < tot_free_nodes ; n++ )
                        {
                            // unsigned long verify_free_bnode_addrs_[num_keys_][max_rdx_nodes_+1]; -> verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+n]
                            unsigned long ul = verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+n];
                            fba.push_back(ul);
                        }

                        std::sort( fba.begin(), fba.end() );

                        n = 0;
                        for( vector<unsigned long>::iterator it = fba.begin(); it != fba.end(); ++it )
                        {
                            verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+n] = *it;
                            n++;
                        }
                    }

                    // sort allocated data node keys
                    {
                        int n = 0;
                        vector<string> dk;  // verify_dnode_keys_[]

                        for ( n = 0 ; n < tot_alloc_nodes ; n++ )
                        {
                            // unsigned char verify_dnode_keys_[num_keys_][max_rdx_nodes_+1][max_key_bytes_]; -> verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]
                            string s( (char *)(&verify_dnode_keys_[(k*(max_rdx_nodes_+1)+0)*max_key_bytes_+(n*max_key_bytes_)]), max_key_bytes_);
                            dk.push_back(s);
                        }

                        std::sort( dk.begin(), dk.end() );

                        n = 0;
                        for( vector<string>::iterator it = dk.begin(); it != dk.end(); ++it )
                        {
                            (*it).copy( (char *)(&verify_dnode_keys_[(k*(max_rdx_nodes_+1)+0)*max_key_bytes_+(n*max_key_bytes_)]), max_key_bytes_ );
                            n++;
                        }
                    }
                }

                // check for multiple nodes with same key in a given key index - in sorted
                // order identical keys will show up next to each other
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    for ( int n = 0 ; n < tot_alloc_nodes-1 ; n++ )
                    {
                        if ( memcmp( &verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+0], &verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n+1)*max_key_bytes_+0], max_key_bytes_ ) == 0 )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 13): Multiple nodes with same key of key index %d"
                                            " and key value\n   ",
                                    __FILE__, __LINE__, k);
                                os << tmpstr;
                                for ( int b = 0 ; b < max_key_bytes_ ; b++ )
                                {
                                    snprintf(tmpstr, sizeof(tmpstr), "%02x ", verify_dnode_keys_[(k*(max_rdx_nodes_+1)+n)*max_key_bytes_+b]);
                                    os << tmpstr;
                                }
                                os << "\n";
                            }
                            return 13;
                        }
                    }
                }

                // walk branch node free list(s) - checking for valid branch node addresses.
                // if head pointer is NULL then the free node list is empty
                for ( int k = 0 ; k < num_keys_ ; k++ )
                {
                    bhead = (BNODE *)(rdx_.bfree_head[k]);

                    // walk data node free list
                    while ( bhead != NULL )
                    {
                        void *ptr;

                        // check if current pointer is in free data node list
                        ptr = bsearch(
                                         (void *)(&bhead),
                                         (void *)(&verify_free_bnode_addrs_[k*(max_rdx_nodes_+1)+0]),
                                         tot_free_nodes,
                                         sizeof(unsigned long),
                                         unsigned_long_compare
                                     );
                        if ( ptr == NULL )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 14): Pointer in branch node free list"
                                            " with key index %d corrupted\n",
                                    __FILE__, __LINE__, k);
                                os << tmpstr;
                            }
                            return 14;
                        }
                        bhead = (BNODE *)(bhead->p);
                    }
                }

                // walk data node free list - checking for valid data node addresses.
                // if head pointer is NULL then the free node list is empty
                dhead = (DNODE *)(rdx_.dfree_head);

                // walk data node free list
                while ( dhead != NULL )
                {
                    void *ptr;

                    // check if current pointer is in free data node list
                    ptr = bsearch(
                                     (void *)(&dhead),
                                     (void *)(&verify_free_dnode_addrs_[0]),
                                     tot_free_nodes,
                                     sizeof(unsigned long),
                                     unsigned_long_compare
                                 );
                    if ( ptr == NULL )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 15): Pointer in data node free list corrupted\n",
                                __FILE__, __LINE__);
                            os << tmpstr;
                        }
                        return 15;
                    }
                    dhead = (DNODE *)(dhead->nnfp);
                }

                // for each allocated node check for valid branch and data node values
                for ( int n = 0 ; n < tot_alloc_nodes ; n++ )
                {
                    unsigned long ui;
                    void *ptr, *bptr, *dptr;


                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        // check if bad branch node id
                        if ( rdx_.bnodes[n*num_keys_+k].id != 0 )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 16): Branch node id at key index %d and node %d not"
                                            " valid - %d\n",
                                    __FILE__, __LINE__, k, n, rdx_.bnodes[n*num_keys_+k].id);
                                os << tmpstr;
                            }
                            return 16;
                        }

                        // check if bad parent branch indicator
                        if ( rdx_.bnodes[n*num_keys_+k].br != 0 && rdx_.bnodes[n*num_keys_+k].br != 1 )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 17): Branch node parent branch boolean of key index %d"
                                            " and node %d not valid - %d\n",
                                    __FILE__, __LINE__, k, n, rdx_.bnodes[n*num_keys_+k].br);
                                os << tmpstr;
                            }
                            return 17;
                        }

                        // check if branch node parent pointers are valid - the root node(i=0) will not have a parent
                        if ( n != 0 )
                        {
                            ui = (unsigned long)rdx_.bnodes[n*num_keys_+k].p;
                            ptr = bsearch(
                                             (void *)(&ui),
                                             (void *)(&verify_bnode_addrs_[k*(max_rdx_nodes_+1)+0]),
                                             tot_alloc_nodes,
                                             sizeof(unsigned long),
                                             unsigned_long_compare
                                         );
                            if ( ptr == NULL )
                            {
                                if ( vm == ERR_CODE_PRINT )
                                {
                                    snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 18): Branch node parent pointer of key index %d"
                                                " and node %d corrupted\n",
                                        __FILE__, __LINE__, k, n);
                                    os << tmpstr;
                                }
                                return 18;
                            }
                        }

                        // check if PATRICIA algorithm branch test bit number is valid
                        if ( rdx_.bnodes[n*num_keys_+k].b > (unsigned int)max_key_bytes_*8 )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 19): Branch node bit number branch test value of"
                                            " key index %d and node %d not valid - %d\n",
                                    __FILE__, __LINE__, k, n, rdx_.bnodes[n*num_keys_+k].b);
                                os << tmpstr;
                            }
                            return 19;
                        }

                        // check if left child pointer is another branch or data node
                        ui = (unsigned long)rdx_.bnodes[n*num_keys_+k].l;
                        bptr = bsearch(
                                          (void *)(&ui),
                                          (void *)(&verify_bnode_addrs_[k*(max_rdx_nodes_+1)+0]),
                                          tot_alloc_nodes,
                                          sizeof(unsigned long),
                                          unsigned_long_compare
                                      );
                        dptr = bsearch(
                                          (void *)(&ui),
                                          (void *)(&verify_dnode_addrs_[0]),
                                          tot_alloc_nodes,
                                          sizeof(unsigned long),
                                          unsigned_long_compare
                                      );
                        if ( bptr == NULL && dptr == NULL )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 20): Branch node left pointer of key index %d"
                                            " and node %d corrupted\n",
                                    __FILE__, __LINE__, k, n);
                                os << tmpstr;
                            }
                            return 20;
                        }

                        // check if right child pointer is another branch or data node
                        // - the root node(i=0) will not have a right child
                        if ( n != 0 )
                        {
                            ui = (unsigned long)rdx_.bnodes[n*num_keys_+k].r;
                            bptr = bsearch(
                                              (void *)(&ui),
                                              (void *)(&verify_bnode_addrs_[k*(max_rdx_nodes_+1)+0]),
                                              tot_alloc_nodes,
                                              sizeof(unsigned long),
                                              unsigned_long_compare
                                          );
                            dptr = bsearch(
                                              (void *)(&ui),
                                              (void *)(&verify_dnode_addrs_[0]),
                                              tot_alloc_nodes,
                                              sizeof(unsigned long),
                                              unsigned_long_compare
                                          );
                            if ( bptr == NULL && dptr == NULL )
                            {
                                if ( vm == ERR_CODE_PRINT )
                                {
                                    snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 21): Branch node right pointer of key index %d"
                                                " and node %d corrupted\n",
                                        __FILE__, __LINE__, k, n);
                                    os << tmpstr;
                                }
                                return 21;
                            }
                        }

                        // check if data node parent pointers are all valid branch node addresses
                        ui = (unsigned long)rdx_.dnodes[n].p[k];
                        ptr = bsearch(
                                         (void *)(&ui),
                                         (void *)(&verify_bnode_addrs_[k*(max_rdx_nodes_+1)+0]),
                                         tot_alloc_nodes,
                                         sizeof(unsigned long),
                                         unsigned_long_compare
                                     );
                        if ( ptr == NULL )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 22): Data node parent pointer of key index %d"
                                            " and node %d corrupted\n",
                                    __FILE__, __LINE__, k, n);
                                os << tmpstr;
                            }
                            return 22;
                        }

                        // check if all data node parent branch indicators are valid
                        if ( rdx_.dnodes[n].br[k] != 0 && rdx_.dnodes[n].br[k] != 1 )
                        {
                            if ( vm == ERR_CODE_PRINT )
                            {
                                snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 23): Data node parent branch boolean of key index %d and"
                                            " node %d not valid - %d\n",
                                    __FILE__, __LINE__, k, n, rdx_.dnodes[n].br[k]);
                                os << tmpstr;
                            }
                            return 23;
                        }
                    }
                }

                // retrieve all keys from all data nodes and use normal search(rdx->search())
                // to find them - ignore root node keys

                // unsigned char key[num_keys_][1+max_key_bytes_]
                unsigned char *key = (unsigned char *)calloc( num_keys_ * (1+max_key_bytes_), sizeof(unsigned char) );

                for ( int n = 1 ; n < tot_alloc_nodes ; n++ )
                {
                    app_data *app_datap;


                    // get data node keys directly from allocated data node
                    for ( int k = 0 ; k < num_keys_ ; k++ )
                    {
                        key[k*(1+max_key_bytes_)+0] = 1;
                        memmove( &key[k*(1+max_key_bytes_)+1], &rdx_.dnodes[n].key[k*(1+max_key_bytes_)+1], max_key_bytes_ );
                    }

                    // search for node n keys
                    app_datap = search(key);

                    if ( app_datap == NULL )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 24): Data node %d searched for with it's keys not found\n",
                                __FILE__, __LINE__, n);
                            os << tmpstr;
                        }
                        return 24;
                    }

                    // do full compare of 'app_data data;' obtained from rdx->search() and the same data obtained from rdx_.dnodes[n].data.
                    // if they do not match, error.
                    if ( memcmp( app_datap, &rdx_.dnodes[n].data, sizeof(app_data) ) != 0 )
                    {
                        if ( vm == ERR_CODE_PRINT )
                        {
                            snprintf(tmpstr, sizeof(tmpstr), "rdx->verify():(file %s  line %d  ERR_CODE 25): compare of 'app_data data;' obtained from rdx->search() and"
                                        " the same data obtained from rdx_.dnodes[%d].data do not match",
                                __FILE__, __LINE__, n);
                            os << tmpstr;
                        }
                        return 25;
                    }
                }
                free(key);

                return 0;
            }  // verify()

    };  // class MKRdxPat

}  // namespace MultiKeyRdxPat

#endif  // RDX_CPP_MKRDXPAT_H_

